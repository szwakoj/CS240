{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CS240 - Data Structures and Algorithms","text":"<p>Welcome to CS 240, Spring 2026!</p> <p>This site serves as the main entry point for the course and will be the means of distributing course material. All information on here will be translated to Brightspace for grades, due dates, and handing in assignments.</p> <p>Important links:</p> <ul> <li>Syllabus - Syllabus of the course, containing critical information about the course</li> <li>Schedule - Course schedule; use primarily as a history of topics, launching point, and 1-2 week look ahead</li> <li>Lessons - The main repository of course material, all lectures are based on these</li> <li>Homeworks - This link takes you to the details of how to hand in homework, as well as all currently given assignments</li> <li>Labs - The course's guided labs, optional and initiated in-person, with students finishing at home</li> </ul> <p>Note on Accessibility</p> <p>This course website was adopted and hand tailored to be in-line with new WCAG accessibility guidelines. If there are any issues accessing its material or if there are features not working properly, please reach me at szwakoj@sunypoly.edu with the subject line \"CS 240 Site Issue\".</p> <p>In addition to offering all course material in this format, the source plain text, markdown files are available at this course's github to be viewed through your markdown viewer of choice. </p>"},{"location":"glossary/","title":"Glossary","text":"<p>Computational Problems: Problems that specify constraints on an input-output relationship.</p> <p>Instance: A single valid input that satisfies the constraints of the problem's intended inputs. Each instance is an example of a possible problem from the formal definition.</p> <p>Algorithms: Solutions to computational problems. They take in a possible instance of the problem and are expected to produce a valid output. The transformation is done using a discrete number of ordered computational steps.</p> <p>Correct Algorithm: An algorithm that halts with the correct output for every input instance. A correct algorithm solves the given computational problem and must terminate in finite time.</p> <p>Incorrect Algorithm: An algorithm that solves only a subset of the possible instances of a computational problem.</p> <p>Data Structure: Methods of storing and organizing data in some medium that allows for easy access and modification.</p> <p>Array: Ordered numbers in a set size of contiguous memory, meaning that all data is stored physically next to each other.</p>"},{"location":"schedule/","title":"Schedule","text":""},{"location":"schedule/#disclaimer","title":"DISCLAIMER","text":"<p>This schedule will be primarily used as a history of topics that we have covered thus far, as well as a short look into the future. To best attend to the class' pace, future looks will be limited to 1-2 weeks ahead with all due dates known when assignments are given and quiz/test dates when they are announced. Any changes made to significant dates will be in the students favor, if they happen. </p> Date Topic Lessons Labs Homework Unit: Introduction 1/19/26 (Week 1) - Syllabus- Introduction to the course 1/26/26 (Week 2) - Basics- C Install IntroductionInstall gcc - Homework 1 : C Review (Due 2/20/26) 2/2/26 (Week 3) - C Review- Arrays and Strings C Review 2/9/26 (Week 4) - Minor Hiccup 2/16/26 (Week 5) - Algorithms- Big O RuntimeBig O Insertion Sort Analysis"},{"location":"syllabus/","title":"Syllabus","text":""},{"location":"syllabus/#course-data-structures-and-algorithms-cs-240","title":"Course: Data Structures and Algorithms (CS 240)","text":"<p>Section: 03</p> <p>CRN: 2860</p> <p>Semester: Spring 2026</p> <p>On-Campus, 4 Credits</p> <p>Room: Kunsela Hall A135 </p> <p>Meeting Times: Tuesdays and Thursdays, 2:00pm - 3:50pm</p>"},{"location":"syllabus/#office-hours-and-contact-info","title":"Office Hours and Contact Info","text":"<p>Instructor: John Szwakob III (Mr. S)</p> <p>Office Location: Kunsela Hall C127</p> <p>Office Hours:</p> <ul> <li> <p>Mondays 2:00pm - 4:00pm</p> </li> <li> <p>Tuesdays and Thursdays, 10:00am - 12:00pm</p> </li> <li> <p>Friday by appointment</p> </li> </ul> <p>Phone: (315) 792-7256</p> <p>Note: This is my office phone, I will be in the office guaranteed during the office hours above, however outside of that I may be teaching or in a meeting if you call during school hours. I encourage you to leave a message. The best way to contact me remains through the email below as I can respond much quicker for time sensitive matters.</p> <p>Email: szwakoj@sunypoly.edu</p>"},{"location":"syllabus/#course-catalog-description","title":"Course Catalog Description:","text":"<p>Fundamental concepts of data structures and the algorithms that proceed from them. Topics include recursion, the underlying philosophy of object-oriented programming, fundamental data structures including stacks, queues, linked lists, hash tables, trees, and graphs. The basics of algorithmic analysis, and an introduction to the principles of language translation. Prerequisite: C grade or higher in CS 108.</p>"},{"location":"syllabus/#course-objectives","title":"Course Objectives:","text":"<ul> <li>Introduce students to classic data structures and algorithms</li> <li>Use Big O notation to evaluate algorithms</li> <li>Learn fundamental data structures by creating them by hand</li> <li>Use the C and C++ programming languages to solve problems efficiently using the concepts in this course</li> </ul>"},{"location":"syllabus/#student-learning-outcomes","title":"Student Learning Outcomes","text":"<p>By the end of this course you will:</p> <ul> <li>Know fundamental data structures like stacks, queues, linked lists, hash tables, trees, graphs, and more</li> <li>Cover standard sorting algorithms</li> <li>Be able to assess the efficiency of an algorithm using Big O notation</li> <li>Analyze functions for possible optimization gains </li> <li>Understand the philosophy behind programming paradigms like functional programming and object-oriented programming</li> <li>Implement classic data structures and algorithms by hand in the C programming language</li> <li>Use C++ as a means of learning modern optimization techniques and current implementations of concepts covered</li> <li>Deconstruct problems in terms of the data structures best fit for them</li> </ul>"},{"location":"syllabus/#text-and-materials","title":"Text and Materials:","text":"<p>There is no required text book, most if not all material will be through this site and in class lectures. There are, however suggested resources for those who learn best with a textbook as reference, as well as the sources for the course.</p> <p>\"Introduction to Algorithms\" by Cormen, Leiserson, Rivest, and Stein (CLRS) (3rd edition)</p> <ul> <li>Textbook that covers the topics in the traditional way, at times it will be referenced</li> </ul> <p>https://en.cppreference.com/ - C and C++ Reference Website</p> <ul> <li>We will regularly use this as our reference for in-class demos on C and C++</li> </ul>"},{"location":"syllabus/#course-schedule","title":"Course Schedule:","text":"<p>Below is the rough topical structure of the course in the order of coverage, you can find this plan and the most updated schedule at the course website. The schedule is a rough outline and will be changed to best serve the classes needs, any changes made will be in favor of the students and any complications can be rectified over email or in-person.</p> <p>These units are a rough organization of the topics in the order covered, they will be about 2-3 weeks each with some time allotted for tests and review. More or less time could be taken depending on the class pace, the latter allowing for more topics to be covered.</p> <ul> <li>Unit Order<ul> <li>Introduction</li> <li>Sorting and Other Algorithms<ul> <li>Insertion</li> <li>Selection</li> <li>Bubble</li> <li>Merge</li> <li>Quick</li> <li>Others</li> </ul> </li> <li>Data Structures<ul> <li>Array and List</li> <li>Stack, Queue, and Linked List</li> <li>Binary Trees</li> <li>Graph</li> <li>Hash Table</li> <li>Others</li> </ul> </li> <li>Algorithmic and Programming Paradigms<ul> <li>Dynamic Programming</li> <li>Basic Object Orientated Programming</li> <li>Functional Programming</li> </ul> </li> </ul> </li> </ul>"},{"location":"syllabus/#method-of-evaluation","title":"Method of Evaluation","text":"<ul> <li>Homeworks <ul> <li>Take home assignments meant to instill concepts covered in class</li> <li>Will often be based on labs or other in-class activities</li> <li>Mostly coding</li> </ul> </li> <li>Attendance Quizzes<ul> <li>Short (2-3 Questions) in-person quizzes given weekly</li> <li>Meant to test topics covered the class previous</li> <li>Can be given on any class day during the week</li> <li>No re-tests</li> <li>Three lowest grades dropped from average</li> </ul> </li> <li>Unit Tests<ul> <li>Longer form (10 - 15 Questions) in-person tests given at the end of each unit</li> <li>Given about every three weeks, announced beforehand</li> <li>Will contain short and long answer questions</li> <li>Based on lesson, homeworks, labs, and attendance quizzes</li> <li>Retests given sparingly and under adequate circumstances</li> <li>Lowest grade dropped from average</li> </ul> </li> <li>Labs<ul> <li>Ungraded guided exercises that are covered in class </li> <li>Students will start them in class and finish them on their own</li> <li>Will prepare students for both homeworks and tests</li> </ul> </li> </ul> Academic Work % of Grade Homework 60% Attendance Quizzes(Weekly) 10% Unit Tests 30% Labs(in-class) Ungraded Total 100%"},{"location":"syllabus/#letter-grading","title":"Letter Grading","text":"Letter Grade Percentage Range A+ 96\u2154 - 100% A 93\u2153 - 96\u2154% A- 90 - 93\u2153% B+ 86\u2154 - 90% B 83\u2153 - 86\u2154% B- 80 - 83\u2153% C+ 76\u2154 - 80% C 73\u2153 - 76\u2154% C- 70 - 73\u2153% D+ 66\u2154 - 70% D 63\u2153 - 66\u2154% D- 60 - 63\u2153% F 0 - 60%"},{"location":"syllabus/#accommodations-for-students-with-accessibility-needs-at-suny-polytechnic-institute","title":"Accommodations for Students with Accessibility Needs at SUNY Polytechnic Institute:","text":"<p>Your access in this course is important to me. In compliance with the Americans with Disabilities Act of 1990 and Section 504 of the Rehabilitation Act of 1973, SUNY Polytechnic Institute is committed to ensuring comprehensive educational access and accommodations for all registered students seeking access to meet course requirements and fully participate in programs and activities. Students with documented disabilities, temporary, or medical conditions are encouraged to request services by contacting Student Accessibility Services (SAS) or filling out the Request for Accommodations form. Please note, requesting accommodations is only the first step. You must provide documentation (the request form may count) to SAS and meet with staff before receiving accommodations. Please do this as early as possible 1) because accommodations are never retroactive and 2) so that we have adequate time to arrange your approved academic accommodation/s.</p> <p>Once SAS creates your accommodation plan, it is your responsibility to provide me a copy of the accommodation plan. If you experience any access barriers in this course, such as with printed content, graphics, online materials, etc., reach out to me or SAS right away. For information related to these services or to schedule an appointment, please contact SAS using the information provided below.</p>"},{"location":"syllabus/#office-of-student-accessibility-services","title":"Office of Student Accessibility Services","text":"<p>Email: SAS@sunypoly.edu</p> <p>Phone: (315) 792-7170</p> <p>Location: Kunsela Hall, B101</p>"},{"location":"syllabus/#content-accessibility","title":"Content Accessibility","text":"<p>SUNY Poly\u2019s goal is for all digital content to be fully accessible but there may be times when remediation is still underway, please let me know if you experience challenges accessing any digital content in this course.</p> <p>This course is attempting to start a new standard for the CS department using open-source tools to make content universally accessible according to any accessibility requirements by producing all content sources in Markdown. By creating it in Markdown and pure text, any accessibility reader can be tooled to a students needs, while allowing for the teacher to rapidly create material in a lasting way.</p> <p>This process will not be without its bumps, so, if there are any issues with accessing the course material or reading it in any way, please contact me ASAP by email at szwakoj@sunypoly.edu.</p>"},{"location":"syllabus/#pregnancy-statement","title":"Pregnancy Statement","text":"<p>SUNY Poly is committed to fostering an inclusive and supportive environment for all students and it does not discriminate against any student based on the student's pregnancy or related conditions. If you have questions or concerns related to pregnancy or related conditions, please contact the Title IX Coordinator, Kathie Artigiani at artigik@sunypoly.edu.</p>"},{"location":"syllabus/#technical-assistance-for-students","title":"Technical Assistance for Students","text":"<p>The following only applies for technologies and materials offered by the school generally and not the ones that this course uses individually. If there are any issues with the course website, programming tools, or homeworks, email the teacher.</p> <p>The SUNY Poly Help Desk is in the Cayan Library on the first floor. You can contact them by phone at 315-792-7440, by email at helpdesk@sunypoly.edu, or by submitting an online help ticket on their website.</p> <p>If the SUNY Poly Help Desk is closed, you can obtain assistance from the Open SUNY Help Desk by calling 1-844-OPENSUNY (673-6786). The Open SUNY email is OpenSUNYHelp@suny.edu or you can submit an online help ticket.</p> <p>The SUNY Poly ITS website has information about software and hardware that you can access as a student, as well as links to software you may need in your classes. Students are encouraged to save all work in multiple locations. MS Office OneDrive is available for use. For assistance, please contact the ITS Help Desk, helpdesk@sunypoly.edu or 315-792-7440. </p>"},{"location":"syllabus/#academic-integrity-and-code-of-conduct","title":"Academic Integrity and Code of Conduct","text":"<p>SUNY Poly is committed to academic excellence in a climate of honesty, respect, and trust. The mutually respectful exchange of honest ideas is foundational to the intellectual vigor of the SUNY Poly community. The University seeks to maintain and enhance its educational environment through the development, promotion, and enforcement of standards for academic integrity. Please take a few minutes to become familiar with SUNY Poly\u2019s Community Standards, including the Student Handbook and Student Code of Conduct. SUNY Poly\u2019s Academic Integrity Policy, which describes SUNY Poly\u2019s policies regarding plagiarism and other inappropriate academic activities, can be found in the Student Handbook. </p>"},{"location":"syllabus/#writing-and-communications-center","title":"Writing and Communications Center","text":"<p>The Writing and Communications Center (WCC) is here to support all of SUNY Poly\u2019s writers: students, faculty, and staff. We offer one-on-one in-person and remote consultations for writers working on a range of projects at any stage of the writing process (from idea generation to final revisions). WCC consultants work with writers on idea development, brainstorming, content development, structure, source use, style, grammar, punctuation, and more. While we are not a proofreading or editing service and we do not comment on grades, we offer strategies and resources writers can use as they compose, revise, edit, and learn to proofread their own work. The WCC is located on the first floor of the Cayan Library. You can learn more about the WCC or make an appointment by visiting our website: https://sunypoly.edu/writingcenter.html.</p>"},{"location":"syllabus/#plagiarism-warning","title":"Plagiarism Warning","text":"<p>All homeworks, quizzes, tests, and labs are meant to be completed by students independently (unless otherwise stated) and without the assistance of generative AI backed by LLMs including, but not limited to, ChatGPT, Claude, Gemini, and all other text/code generators. All material that is assigned to students is meant to instill lasting critical thinking and problem solving skills that are required to excel in both this course and wherever students may end up in the future. As such, usage of these tools in a fashion akin to plagiarism (not citing, wholesale copying, intent to hide sources) is strictly prohibited in this course. All incidents that can be proven must be brought to the dean and always results in a zero on the grade. This goes for plagiarizing code from other sources, such as StackOverflow, Reddit, Github, other uncited sources, and fellow students.</p> <p>That being said, using other sources as reference is not completely out of the question. Peers, tutorials, YouTube videos, existing code, and even LLMs can greatly aid in understanding complex topics. However, they cannot be used without disclosure and proper citation if being used extensively in an assignment. Use other sources and LLMs cautiously as this course is based on the lessons found within the the lectures given in-person.</p>"},{"location":"syllabus/#policy-on-submission-of-assignments","title":"Policy on Submission of Assignments","text":"<p>All assignments will be submitted via Brightspace in the appropriate location identified by each assignment. Specific instructions can be found on the course website. Each assignment will be given with an intended due date attached. For each day late an assignment is, a 10% reduction will be removed from the maximum possible grade, capped at 50%, so long as a valid final submission has been made by the end of the semester.</p>"},{"location":"syllabus/#policy-on-missed-classes-make-up-work-andor-extra-credit","title":"Policy on Missed Classes, Make-up Work, and/or Extra Credit:","text":"<p>There is no method of attendance other than the attendance quizzes given weekly. Make-up attendance quizzes are not allowed due to being a measure of how often students come to the class and the dropping of the three lowest grades before final grading. Make-up unit tests are allowed if there is good reason and preferably known about ahead of time.</p> <p>Extra credit may be given, in this event it will be announced in-class.</p>"},{"location":"syllabus/#cancellation-of-classes-due-to-inclement-weather-or-other-emergency","title":"Cancellation of Classes Due to Inclement Weather or Other Emergency:","text":"<p>SUNY Poly has a 24-hour hotline, called Snowline, to inform students, faculty, and staff when severe weather prompts the cancellation of all classes. Snowline can be reached by calling 315-792-7385. In the event of severe weather, Snowline will announce only the cancellation of ALL classes. The cancellation of all classes will also be posted online and broadcast on radio and television stations in the Utica Rome and Syracuse areas. The SUNY Poly website also maintains a list of individual class cancellations.</p> <p>In addition, all SUNY Poly students and employees are enrolled in the Rave Alert emergency alert service. You can visit the SUNY Poly Rave Alert website to learn more and to adjust your notification preferences. </p>"},{"location":"homework/1_c_review/","title":"C Review: Text Adventure Game","text":""},{"location":"homework/1_c_review/#due-date-22026","title":"Due Date: 2/20/26","text":""},{"location":"homework/1_c_review/#description","title":"Description:","text":"<p>In this homework, you will construct a text adventure game in the style of classics like Zork, The Hobbit, and The Hitchhiker's Guide to the Galaxy but simplified to a manageable scope. You are to create a text adventure in the command-line using the C programming language and rooms that I provide in the form of text files. You will be implementing the data structures and algorithms to facilitate the gameplay and read in arbitrary room files.</p> <p>If you are unfamiliar to the idea of a text-based adventure game, here are some defining features:</p> <ul> <li>A terminal interface for the user to enter action commands from a narrow subset<ul> <li>Commands like \"look\", \"go {north|east|south|west}\", and \"grab {item}\" are classic examples</li> </ul> </li> <li>Text that prompts the user as to where they are in the game world<ul> <li>\"You awake in your bed room in the South side of the room. To the North is the door to the rest of your house. To the West, your window. To the East, is your desk with something shiny on it\"</li> </ul> </li> <li>A method of keeping track of player actions<ul> <li>Usually an inventory of items that puzzles require for solving</li> </ul> </li> <li>If you want a better idea, click this link, to go to a web-based version of ZORK. Play for a little while to get the gist and experience video game history </li> </ul> <p>To make sure the scope doesn't go too wild for a first assignment the following restrictions and changes will be made to the program you produce by the end of the assignment:</p> <ul> <li>I will provide template rooms that you will fill in</li> <li>You will read in data into a Room data structure</li> <li>You will only need to implement movement and looking for the commands <ul> <li>I.e. \"go North\", \"go South\" \"look\"</li> </ul> </li> <li>After that you make it your own and add at least 2 more rooms</li> </ul> <p>In order to accomplish this game, we are going to split the work into to main parts:</p> <ul> <li>Section 1: Setting Up<ul> <li>This part will focus on setting up the basic data structures, reading file data, and creating the user interface for a small version of the full game</li> <li>You will start by parsing a room files that I provide to you, creating a struct to store that data, and navigating the basic rooms by implementing the movement command parser</li> </ul> </li> <li>Section 2: Customize and reflect<ul> <li>Customize the existing rooms and add at least 2 more rooms</li> <li>Answer some reflection questions</li> </ul> </li> </ul>"},{"location":"homework/1_c_review/#section-1-setting-up-basic_gamec","title":"Section 1: Setting Up (basic_game.c)","text":"<p>Click here , to download the starting point that I have created for you. It is also on Brightspace, under Content-&gt;Homework 1. Unzip it into the place you are completing Homework 1, Section 1. </p>"},{"location":"homework/1_c_review/#overview","title":"Overview","text":"<p>In this section, you will build the foundation for your text adventure game. You'll work with the provided starter code that reads room information from files and displays it. Your job is to:</p> <ol> <li>Define a Room struct to store room data</li> <li>Build an array of rooms from the file data</li> <li>Parse connections between rooms</li> <li>Implement a game loop with basic movement commands</li> </ol> <p>The starter code provides the following files:</p> <ul> <li><code>rooms.txt</code>: Contains the number of rooms and a list of filenames for individual room files</li> <li><code>connections.txt</code>: Contains information about which rooms connect to each other and in which direction</li> <li>Individual room files (e.g., <code>0_enter.txt</code>, <code>1_middle.txt</code>): Each contains a room name and description</li> </ul> <p>Currently the starting code is showing how to read in the file data, your job is to store it in a data structure and make algorithms on top of it.</p>"},{"location":"homework/1_c_review/#task-1-define-the-room-struct-10-points","title":"Task 1: Define the Room Struct (10 points)","text":"<p>Create a <code>Room</code> struct that can store all necessary information about a room:</p> <ul> <li>Room name (string)</li> <li>Room description (string)</li> <li>Connections to other rooms in four directions: North, South, East, West<ul> <li>Hint: Use integers to store the room indices, with -1 indicating no connection in that direction</li> </ul> </li> <li>A flag indicating if it is the exit, if you reach this room the games over</li> <li>Optional: A flag indicating if this room contains a key (for Section 2)</li> <li>Optional: A flag indicating if this room has a locked door (for Section 2)</li> </ul>"},{"location":"homework/1_c_review/#task-2-load-rooms-into-memory-20-points","title":"Task 2: Load Rooms into Memory (20 points)","text":"<p>Modify the provided code to:</p> <ol> <li>Allocate an array of <code>Room</code> structs based on <code>num_rooms</code></li> <li>For each room file, read the name and description and store them in the corresponding struct</li> <li>Initialize all direction connections to -1 (no connection)</li> </ol> <p>Hints:</p> <ul> <li>You'll need to use <code>malloc()</code> to allocate the array</li> <li>Use <code>strcpy()</code> to copy strings into your struct fields</li> <li>Don't forget to allocate space for the strings inside each struct</li> </ul>"},{"location":"homework/1_c_review/#task-3-parse-room-connections-20-points","title":"Task 3: Parse Room Connections (20 points)","text":"<p>Write code to read <code>connections.txt</code> and populate the connection information in your room array. The format of <code>connections.txt</code> is:</p> <p>First line: Number of connections</p> <p>Subsequent lines:</p> <pre><code>&lt;room_index&gt; &lt;direction1&gt; &lt;direction2&gt; &lt;connected_room_index&gt;\n</code></pre> <p>Where:</p> <ul> <li><code>room_index</code> is the index of the room in your array (the \"from\" room)</li> <li><code>direction1</code> is the direction FROM room_index (one of: <code>N</code>, <code>S</code>, <code>E</code>, <code>W</code>)</li> <li><code>direction2</code> is the opposite direction FROM connected_room_index back to room_index</li> <li><code>connected_room_index</code> is the index of the room it connects to (the \"to\" room)</li> </ul> <p>Example <code>connections.txt</code>:</p> <p><pre><code>2\n0 W E 1\n1 N S 2\n</code></pre>  This means:</p> <ul> <li>Line 1: There are 2 connections total</li> <li>Line 2: Room 0 connects West to room 1, and room 1 connects East back to room 0</li> <li>Line 3: Room 1 connects North to room 2, and room 2 connects South back to room 1</li> </ul> <p>Important Notes:</p> <ul> <li>Each connection is bidirectional and defined on a single line</li> <li>The first direction is from the perspective of the first room</li> <li>The second direction is from the perspective of the second room</li> <li>You need to update BOTH rooms' connection arrays when parsing each line</li> </ul> <p>Example parsing logic:</p> <pre><code>void load_connections(Room* rooms, const char* filename) {\n    FILE* conn_file = fopen(filename, \"r\");\n\n    int num_connections;\n    fscanf(conn_file, \"%d\", &amp;num_connections);\n\n    for(int i = 0; i &lt; num_connections; i++) {\n        int room1, room2;\n        char dir1, dir2;\n\n        fscanf(conn_file, \"%d %c %c %d\", &amp;room1, &amp;dir1, &amp;dir2, &amp;room2);\n\n        // Set connection from room1 in direction dir1 to room2\n        // Set connection from room2 in direction dir2 to room1\n        // You'll need to convert 'N', 'S', 'E', 'W' to array indices\n    }\n\n    fclose(conn_file);\n}\n</code></pre>"},{"location":"homework/1_c_review/#task-4-implement-game-loop-with-movement-30-points","title":"Task 4: Implement Game Loop with Movement (30 points)","text":"<p>Create a game loop that:</p> <ol> <li>Keeps track of the current room (start at room 0)</li> <li>Displays the current room name and description</li> <li>Shows available exits (which directions have connections)</li> <li>Prompts the user for a command</li> <li>Parses the command:<ul> <li><code>look</code> - redisplays current room information</li> <li><code>go &lt;direction&gt;</code> - moves to the connected room in that direction (north/south/east/west)</li> <li><code>quit</code> - exits the game</li> <li>Optional: Zork had a <code>hello</code> command that would spur a random greeting when called</li> </ul> </li> <li>Handles invalid commands gracefully with error messages</li> </ol> <p>Hints:</p> <ul> <li>After everything is loaded, a loop needs to be entered that constantly will be asking for input and executing it, checking to see if quit or if the final room has been entered</li> <li>Use strcmp() to compare user strings to commands         - Unfortunately, you cannot find a meaningful way out of an if-else for each statement (ie we cannot use <code>switch</code>)</li> </ul>"},{"location":"homework/1_c_review/#task-5-memory-management-10-points","title":"Task 5: Memory Management (10 points)","text":"<p>Ensure proper memory management (clean up after yourself):</p> <ul> <li>Free all dynamically allocated memory before the program exits</li> <li>Free memory for strings within each room struct</li> <li>Free the room array itself</li> </ul>"},{"location":"homework/1_c_review/#section-1-grading-rubric","title":"Section 1 Grading Rubric","text":"<ul> <li>Task 1: Room struct definition (10 points)</li> <li>Task 2: Loading rooms from files (20 points)</li> <li>Task 3: Parsing connections (20 points)</li> <li>Task 4: Game loop and movement (30 points)</li> <li>Task 5: Memory management (10 points)</li> <li>Code style and comments (10 points)</li> <li>Total: 100 points</li> </ul>"},{"location":"homework/1_c_review/#section-2-customize-and-reflect","title":"Section 2: Customize and Reflect","text":""},{"location":"homework/1_c_review/#overview_1","title":"Overview","text":"<p>Now that you have a working game with the provided rooms, you'll make it your own by customizing the existing rooms and adding at least 2 new rooms of your own design. You'll also reflect on your experience working in C.</p>"},{"location":"homework/1_c_review/#task-1-customize-existing-rooms-20-points","title":"Task 1: Customize Existing Rooms (20 points)","text":"<p>Modify the room description files I provided to create your own narrative:</p> <ul> <li>Change room names to fit your theme</li> <li>Rewrite room descriptions with your own creative text</li> <li>Change connections as you like</li> </ul> <p>Examples of themes:</p> <ul> <li>SUNY Poly Campus Areas</li> <li>NYS Road Trip with Cities</li> <li>Classic Fantasy Adventure</li> <li>Cyberpunk</li> </ul>"},{"location":"homework/1_c_review/#task-2-add-at-least-2-new-rooms-30-points","title":"Task 2: Add At Least 2 New Rooms (30 points)","text":"<p>Expand your game world by:</p> <ol> <li>Creating at least 2 new room text files following the same format</li> <li>Updating <code>rooms.txt</code> to include your new room files</li> <li>Updating <code>connections.txt</code> to connect your new rooms to the existing world</li> <li>Ensuring at least one new room is the exit room</li> </ol> <p>Requirements:</p> <ul> <li>New rooms must be reachable from the starting room</li> <li>At least one room should be a dead-end (requires backtracking)</li> <li>The exit room should be one of your new rooms</li> </ul> <p>Deliverable:</p> <ul> <li>New room text files</li> <li>Updated <code>rooms.txt</code> and <code>connections.txt</code></li> <li>Your game should now have at least 5 total rooms</li> </ul>"},{"location":"homework/1_c_review/#task-3-test-your-game-10-points","title":"Task 3: Test Your Game (10 points)","text":"<p>Play through your game multiple times to ensure:</p> <ul> <li>All rooms are reachable</li> <li>All connections work bidirectionally</li> <li>The exit room properly ends the game</li> </ul> <p>Deliverable: A walkthrough text file (<code>walkthrough.txt</code>) showing the exact commands to reach the exit from the start.</p> <p>Example:</p> <pre><code>go north\ngo east\nlook\ngo south\ngo west\n</code></pre>"},{"location":"homework/1_c_review/#task-4-reflection-questions-30-points","title":"Task 4: Reflection Questions (30 points)","text":"<p>Answer the following questions in a file called <code>reflection.txt</code>. Each answer should be 2-4 sentences.</p> <ol> <li> <p>Strings and Arrays Handling: What challenges did you face working with C strings (char arrays)? What did C strings allow for that other array types didn't?</p> </li> <li> <p>Graph Data Structure: The entire game that has been made resembles a graph. This is a very important data structure that we will revisit once again. What are the benefits of a graph data structure? What other situations do graphs lend well to?</p> </li> <li> <p>Rooms vs Nodes: We have restricted ourselves with the Room data structure. Normal graphs usually can have any number of connections to individual nodes. How did we limit our game? How could we expand it by redesigning the data structure?</p> </li> <li> <p>Drawing: With the fact that you have a graph in this game, draw the map of your game and include it in the submission. Save as <code>graph.png</code> or other valid file type.</p> </li> </ol>"},{"location":"homework/1_c_review/#task-5-code-quality-10-points","title":"Task 5: Code Quality (10 points)","text":"<p>Ensure your final submission has:</p> <ul> <li>Consistent indentation and formatting</li> <li>Meaningful variable and function names</li> <li>Comments explaining complex logic</li> </ul>"},{"location":"homework/1_c_review/#section-2-grading-rubric","title":"Section 2 Grading Rubric","text":"<ul> <li>Task 1: Customize existing rooms (20 points)</li> <li>Task 2: Add new rooms (30 points)</li> <li>Task 3: Walkthrough (10 points)</li> <li>Task 4: Reflection questions (30 points)</li> <li>Task 5: Code quality (10 points)</li> <li>Total: 100 points</li> </ul>"},{"location":"homework/1_c_review/#submission-guidelines","title":"Submission Guidelines","text":""},{"location":"homework/1_c_review/#what-to-submit","title":"What to Submit","text":"<p>Create a ZIP file named <code>CS240-HW1-LastName.zip</code> containing:</p>"},{"location":"homework/1_c_review/#section-1-in-folder-named-section1","title":"Section 1 (in folder named <code>section1/</code>):","text":"<ul> <li><code>basic_game.c</code> - Your completed source code</li> <li><code>room_files</code> - directory containing the following<ul> <li>All room files used</li> <li><code>rooms.txt</code> and <code>connections.txt</code></li> </ul> </li> </ul>"},{"location":"homework/1_c_review/#section-2-in-folder-named-section2","title":"Section 2 (in folder named <code>section2/</code>):","text":"<ul> <li><code>custom_game.c</code> - Your completed source code</li> <li><code>room_files</code> - directory containing the following<ul> <li>All room files used in your customized version</li> <li><code>rooms.txt</code> and <code>connections.txt</code></li> </ul> </li> <li><code>reflection.txt</code> - reflection question answers</li> <li><code>graph.png</code> - Your graph drawing</li> </ul>"},{"location":"homework/gcc_install/","title":"Installation Process","text":""},{"location":"homework/gcc_install/#gcc-install","title":"GCC Install","text":"<p>GCC or the GNU Compiler Collection is an open source collection of programming tools for lower-level languages like C, C++, FORTRAN, and Assembly. We will be using it to compile and run the programs for demos and homeworks using it.</p>"},{"location":"homework/gcc_install/#windows","title":"Windows","text":"<p>There are many methods to install gcc on Windows-based system, each attempting to stream-line some part of the process. We will be using WinLibs GCC pre-compiled version of the collection and manually adding it to the PATH so that you may use the programs in Windows CMD.</p> <ol> <li>Go to https://winlibs.com/:    </li> <li>Scroll down to the Download section:    </li> <li>Click on the red-circled \"Download it here\" to download the latest release for Windows 64-bit systems. If you need the 32-bit version for some reason, it is below. All modern computers are 64-bit so you should be fine with that.</li> <li>That will download a zip file inside of your \"Downloads\" folder:    </li> <li>Right click on the file and select \"Extract All\", or use the top tools to select the same option as in the image:    </li> <li>That will open up a new dialog box asking where to extract the file contents to, click \"Browse\":    </li> <li> <p>Using the File Explorer's side bar menu, scroll down to find \"This PC-&gt;C:\", click it, then press the \"Select Folder\" button, as indicated:    </p> </li> <li> <p>Click \"Extract\", and wait for the process to complete:</p> </li> <li> <p>The compiler is now installed, however your windows Command Prompt cannot use the compiler and other tools until their locations have been added to the PATH. Click the search bar on the task bar and search for  \"environment variables\", click on the \"Edit the system environment variables\" option:    </p> </li> <li>Click on the \"Environment Variables...\" button:     </li> <li>With the new menu that pops up, click on the \"Path\" option under \"System variables\", NOT the one that is for your account. With that selected click on the \"Edit...\" button:     </li> <li>In the new window, click \"New\" to add a new line to the PATH, then click \"Browse...\":     </li> <li>With the new file explorer open, go to \"This PC-&gt;Local Disk (C:)-&gt;mingw64-&gt;bin\", with \"bin\" as the selected folder:     </li> <li>Click \"OK\"</li> <li>Click \"OK\"</li> <li>Click \"OK\"</li> <li>Click \"OK\"</li> <li>GCC has now been installed on your Windows computer! To test this, search cmd in the search bar to open the command prompt</li> <li>Type <code>gcc</code>, and press enter</li> <li>This should result in the following error:     </li> <li>If something else happens, try the process again pay sure to follow the instructions and that you are always downloading and installing into local directories and not those on \"OneDrive\" or other such networked drives</li> <li>If you continue to struggle, bring it up in class, or email me</li> </ol>"},{"location":"homework/gcc_install/#mac","title":"Mac","text":"<p>Apple products have their own suite of gcc tools installed by default, but to be sure that you have full access to them, we will be installing the GNU versions via Homebrew.</p> <ol> <li>Go to https://brew.sh/</li> <li>Follow the instructions there to install brew. It should be<ol> <li>Open macOS terminal</li> <li>Copy-Paste the command below    <code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"</code></li> <li>Run and let it do its thing</li> </ol> </li> <li>With that installed, keep the terminal open and type: <code>brew install gcc</code></li> <li>And you are all done, you should now have access to the gcc command</li> <li>You may test it similarly to the Windows test above, when run without any files given it should produce an error that says \"no input files\". If it says command not found, something is wrong and contact me.</li> </ol>"},{"location":"homework/gcc_install/#linux","title":"Linux","text":"<p>Usually during the installation process you install gcc and the other build tools as a consequence. If not just use your native package manager and install gcc.</p>"},{"location":"homework/gcc_install/#text-editor-or-ide-install","title":"Text Editor or IDE Install","text":"<p>There is no required text editor for this course, however for nearly all of the in-class demos I will be using Sublime Text as my primary text editor. </p> <p>Integrated development environments or IDEs are a little too high-level for courses and remove some of the learning process for students. They also may end up becoming topics to learn in themselves. So, while there is no hard ban on students using tools like VScode or other powerful coding platforms, I strongly suggest the use of simple text editors like Sublime Text.</p> <p>To install Sublime Text, go to https://www.sublimetext.com/ and it will have a specialized installation process for your system on the website. Just click the button that says \"Download for (YOUR SYSTEM)\", and follow the instuctions.</p>"},{"location":"homework/how_to_hand_in/","title":"How To Hand In","text":"<p>During this semester we will have different kinds of assignments meant to aid in understanding, test your skills, and prepare you for the later examinations.</p>"},{"location":"homework/how_to_hand_in/#format-of-submissions","title":"Format of Submissions","text":"<p>Depending on the format of the assignment, you may be asked to produce different types of artifacts to accomplish the given problem set, sometimes multiple different kinds in a single set. </p> <p>Some of the most common type of problems in the HWs will be, along with the general guidelines of how they should be presented:</p> <ul> <li>Coding Problems - Problems that require the generation of source code that meets all requirements of the HW specification<ul> <li>Hand this in as the source code files with the intended programming language file extension</li> <li>Unless told specifically, DO NOT include executables or binaries made for YOUR system. Only hand in source code</li> </ul> </li> <li>Written Problems - These will have you generating natural language responses for a given prompt, length varying and specified in each problem<ul> <li>These can be handed in the following file types:<ul> <li>.txt, .md, .pdf, .docx</li> </ul> </li> <li>If you intend to hand-write answers, you may, however write legibly and scan your answers in one of the following types<ul> <li>.pdf, .png, .jpg</li> </ul> </li> </ul> </li> <li>Drawing Problems - At times I will ask for images to be generated by you as assignments, these can be completed by hand, on tablets, or using some drawing software<ul> <li>Hand these in similarly to the above, in fact at times written and drawing problems may be in a single section</li> </ul> </li> </ul>"},{"location":"homework/how_to_hand_in/#organization-of-files","title":"Organization of Files","text":"<p>Many assignments will contain multiple parts or sections in each, requiring the creation of multiple files in the same and different file types. To keep everything organized with how I am expecting the submissions we will be following the structure below:</p> <ul> <li>Each completed homework should be submitted as a single .zip file that contains:<ul> <li>A folder for each section of homework containing:<ul> <li>All generated files from that section in appropriate file types as listed above</li> </ul> </li> </ul> </li> </ul> <p>For example, if there was the following homework:</p> <ul> <li>Homework 0: Fake Homework<ul> <li>Section 1: Do some code<ul> <li>Code 1</li> <li>Code 2</li> </ul> </li> <li>Section 2: Do some writing<ul> <li>Questions</li> </ul> </li> <li>Section 3: Do some drawing<ul> <li>Questions</li> </ul> </li> </ul> </li> </ul> <p>The file structure should look like this: <pre><code>CS240-HW0-LastNamezip\n\u251c\u2500\u2500 Section1/\n\u2502   \u251c\u2500\u2500 code1.c\n\u2502   \u2514\u2500\u2500 code2.c\n\u251c\u2500\u2500 Section2/\n\u2502   \u2514\u2500\u2500 answers.txt\n\u2514\u2500\u2500 Section3/\n    \u2514\u2500\u2500 drawings.png\n</code></pre></p> <p>If you noticed, I also have an intended naming scheme. Name the overall .zip submission in the form \"CS240-HW{HW number}-{Student Last Name}.zip\". Each section and file will be specified individually for each assignment, be sure to pay attention to it.</p>"},{"location":"homework/how_to_hand_in/#where-to-hand-in","title":"Where to hand in","text":"<p>While the course material and the homework problems are posted here, on this website, all submissions of assignments will be done on the SUNY Poly's Brightspace system. This will also be where all of your grades for assignments and quizzes will be located. This is to ensure grades are in a single place as well as utilize Brightspace's submission system.</p> <p>I will show this off in class and generate images of the process at a later date, however most if not all other courses at SUNY Poly use Brightspace, so I am sure you are acquainted  with it. </p>"},{"location":"labs/1_insertion_breakdown/","title":"Lab 1: Insertion Sort Algorithm Time Complexity","text":"<p>Insertion sort is a simple sorting algorithm that builds the final sorted array one item at a time. It works similarly to how you might sort playing cards in your hands - you pick up cards one at a time and insert them into their correct position among the cards you've already sorted.</p> <p>Here is the algorithm with the time costs and number of times each line runs:</p> <ul> <li>Algorithm: Insertion Sort<ul> <li>Input: An array \\(A\\) of \\(n\\) numbers \\([a_0, a_1, ..., a_{n-1}]\\)</li> <li>Output: The array \\(A\\) sorted in non-decreasing order</li> <li>Procedure:</li> </ul> </li> </ul> No. Step \\(c_i\\) Number of Times 1 \\(\\text{for } i \\gets 1 \\text{ to } n-1 \\text{ do:}\\) \\(c_1\\) \\(n\\) 2 \\(key \\gets A[i]\\) \\(c_2\\) \\(n-1\\) 3 \\(j \\gets i - 1\\) \\(c_3\\) \\(n-1\\) 4 \\(\\text{while } j \\geq 0 \\text{ and } A[j] &gt; key \\text{ do:}\\) \\(c_4\\) \\(\\sum_{i=1}^{n-1}t_i\\) 5 \\(A[j+1] \\gets A[j]\\) \\(c_5\\) \\(\\sum_{i=1}^{n-1}(t_i-1)\\) 6 \\(j \\gets j - 1\\) \\(c_6\\) \\(\\sum_{i=1}^{n-1}(t_i-1)\\) 7 \\(\\text{end while}\\) 0 - 8 \\(A[j+1] \\gets key\\) \\(c_8\\) \\(n-1\\) 9 \\(\\text{end for}\\) 0 - <p>Here, \\(t_i\\) denotes the number of times the while loop test in line 4 is executed for a particular value of \\(i\\). Notice that:</p> <ul> <li>The outer loop runs from \\(i=1\\) to \\(n-1\\), so it executes \\(n-1\\) times</li> <li>For each iteration \\(i\\), the while loop condition is checked \\(t_i\\) times</li> <li>The body of the while loop (lines 5-6) executes \\(t_i - 1\\) times (one less than the condition check, since the final check fails and exits the loop)</li> </ul> <p>The value of \\(t_i\\) varies based on the input configuration, giving us different cases to analyze.</p>"},{"location":"labs/1_insertion_breakdown/#best-case-analysis","title":"Best Case Analysis","text":"<p>The best case occurs when the array is already sorted in non-decreasing order. In this scenario:</p> <ul> <li>For each iteration \\(i\\), when we compare \\(key\\) (which is \\(A[i]\\)) with \\(A[j]\\) (which is \\(A[i-1]\\))</li> <li>Since the array is already sorted, \\(A[i-1] \\leq A[i]\\), so the condition \\(A[j] &gt; key\\) is immediately false</li> <li>The while loop condition is checked exactly once (\\(t_i = 1\\)) and the body never executes (\\(t_i - 1 = 0\\))</li> </ul> <p>Therefore, in the best case:</p> \\[T(n) = c_1(n) + c_2(n-1) + c_3(n-1) + c_4(n-1) + c_5(0) + c_6(0) + c_8(n-1)\\] <p>Simplifying:</p> \\[T(n) = c_1n + c_2(n-1) + c_3(n-1) + c_4(n-1) + c_8(n-1)\\] \\[T(n) = c_1n + (c_2 + c_3 + c_4 + c_8)(n-1)\\] \\[T(n) = c_1n + (c_2 + c_3 + c_4 + c_8)n - (c_2 + c_3 + c_4 + c_8)\\] \\[T(n) = (c_1 + c_2 + c_3 + c_4 + c_8)n - (c_2 + c_3 + c_4 + c_8)\\] <p>If we let \\(a = c_1 + c_2 + c_3 + c_4 + c_8\\) and \\(b = c_2 + c_3 + c_4 + c_8\\):</p> \\[T(n) = an - b\\] <p>This is a linear function of \\(n\\). The best-case time complexity of insertion sort is therefore:</p> \\[\\Omega(n)\\] <p>This means insertion sort runs in at least linear time - it cannot be faster than checking each element at least once.</p>"},{"location":"labs/1_insertion_breakdown/#worst-case-analysis","title":"Worst Case Analysis","text":"<p>The worst case occurs when the array is sorted in reverse order (strictly decreasing). In this scenario:</p> <ul> <li>For each iteration \\(i\\), the element \\(A[i]\\) must be compared with all elements before it</li> <li>Each comparison shows that \\(A[j] &gt; key\\), so we keep moving backwards</li> <li>The while loop continues until \\(j &lt; 0\\)</li> <li>For position \\(i\\), we make \\(i+1\\) comparisons (checking positions \\(i-1, i-2, ..., 1, 0\\), and then checking if \\(j \\geq 0\\) fails)</li> <li>The body executes \\(i\\) times</li> </ul> <p>Therefore: \\(t_i = i + 1\\) for each \\(i\\) from \\(1\\) to \\(n-1\\)</p> <p>Computing the sums:</p> \\[\\sum_{i=1}^{n-1}t_i = \\sum_{i=1}^{n-1}(i+1) = \\sum_{i=1}^{n-1}i + \\sum_{i=1}^{n-1}1 = \\frac{(n-1)n}{2} + (n-1) = \\frac{n^2 + n - 2}{2}\\] \\[\\sum_{i=1}^{n-1}(t_i-1) = \\sum_{i=1}^{n-1}i = \\frac{(n-1)n}{2}\\] <p>Now we can calculate the worst-case runtime:</p> \\[T(n) = c_1(n) + c_2(n-1) + c_3(n-1) + c_4\\left(\\frac{n^2+n-2}{2}\\right) + c_5\\left(\\frac{n(n-1)}{2}\\right) + c_6\\left(\\frac{n(n-1)}{2}\\right) + c_8(n-1)\\] <p>Simplifying by expanding and collecting terms:</p> \\[T(n) = c_1n + c_2(n-1) + c_3(n-1) + \\frac{c_4n^2 + c_4n - 2c_4}{2} + \\frac{c_5n^2 - c_5n}{2} + \\frac{c_6n^2 - c_6n}{2} + c_8(n-1)\\] \\[T(n) = \\frac{c_4 + c_5 + c_6}{2}n^2 + \\left(c_1 + c_2 + c_3 + \\frac{c_4 - c_5 - c_6}{2} + c_8\\right)n - (c_2 + c_3 + c_4 + c_8)\\] <p>If we let \\(a = \\frac{c_4 + c_5 + c_6}{2}\\), \\(b = c_1 + c_2 + c_3 + \\frac{c_4 - c_5 - c_6}{2} + c_8\\), and \\(c = c_2 + c_3 + c_4 + c_8\\):</p> \\[T(n) = an^2 + bn - c\\] <p>This is a quadratic function of \\(n\\). The worst-case time complexity of insertion sort is therefore:</p> \\[O(n^2)\\]"},{"location":"labs/1_insertion_breakdown/#summary","title":"Summary","text":"<p>Insertion sort has:</p> <ul> <li>Best case: \\(\\Omega(n)\\) - linear time when the array is already sorted</li> <li>Worst case: \\(O(n^2)\\) - quadratic time when the array is reverse sorted</li> <li>Average case: \\(\\Theta(n^2)\\) - for random inputs, on average the while loop executes about half the maximum times, which still results in quadratic growth</li> </ul> <p>This analysis shows why insertion sort is efficient for small or nearly-sorted datasets (where it approaches linear time) but becomes slow for large, randomly ordered datasets (where it exhibits quadratic behavior). For small values of \\(n\\) (typically \\(n &lt; 50\\)), insertion sort can actually be faster than more advanced algorithms due to its low constant factors and simple operations, but as \\(n\\) grows large, the quadratic growth dominates and makes it impractical compared to algorithms like merge sort or quicksort which have \\(O(n \\log n)\\) worst-case or average-case complexity.</p>"},{"location":"labs/2_array_lab/","title":"Lab 2: Arrays, Strings and Structs","text":"<p>Soon</p>"},{"location":"lessons/1_introduction/","title":"Introduction","text":"<p>This course is concerned with the study of data structures and algorithms in computer science. This lesson serves as an introduction to some of the core concepts that we will be building on over the course of this semester. Here we cover:</p> <ul> <li> <p>Computational Problems</p> </li> <li> <p>Algorithms Basics</p> </li> <li> <p>Introduce Data Structures</p> </li> </ul>"},{"location":"lessons/1_introduction/#algorithms","title":"Algorithms","text":"<p>What are algorithms? Algorithms have been at the core of your computer science journey since its beginning, however before understanding them more deeply, we must first know why they exist in the first place.</p>"},{"location":"lessons/1_introduction/#problems","title":"Problems","text":"<p>Even in your most rudimentary programs, you can understand them as solutions to some problem, or at least attempts at them. These problems can be as simple as to sort a list, find a max, or calculate an average, or as complex as retrieving the correct webpage given a search, training artificial intelligence systems efficiently, or landing a drone. All of the previous can be formalized into computational problems; problems that specify constraints on an input-output relationship.</p> <p>One such problem we will be tackling is the sorting problem, usually defined as:</p> <ul> <li>Plain English<ul> <li>Take in a sequence of amount of numbers and produce a sequence of the same numbers in order of least to greatest</li> </ul> </li> <li>Formal Definition<ul> <li>Input: An array \\(A\\) of \\(n\\) numbers \\([ a_0 , a_1, ..., a_{n-1} ]\\), where \\(n &gt; 0\\)</li> <li>Output: A permutation (reordering) \\([ a^{\\prime}_0 , a^{\\prime}_1, ..., a^{\\prime}_{n-1} ]\\) of the input sequence such that \\(a^{\\prime}_0 \\leq a^{\\prime}_1 \\leq ... \\leq a^{\\prime}_{n-1}\\)</li> </ul> </li> </ul> <p>Sorting is a very important operation in computer science, many problems require or are more easily solved if a sequence is ordered. It would be a good idea to absorb the definition of the sorting problem as we will be programming it and solutions to it soon.</p> <p>By formalizing the problem into a mathematical representation, we now have a general way of understanding the problem regardless of how we implement a check for it. The formal definition also gives a means of defining what a valid input is, or if something is an instance of the problem</p> <p>A single instance of a problem is a single valid input that satisfies the constraints of the problem's intended inputs. Each instance is an example of a possible problem from the formal definition. For our previous problem:</p> <ul> <li>Instance of Sorting Problem<ul> <li>\\(\\langle 70, 55, 86, 12, 72, 20, 31, 3 \\rangle\\)</li> </ul> </li> <li>Intended Output<ul> <li>\\(\\langle 3, 12, 20, 31, 55, 70, 72, 86\\rangle\\)</li> </ul> </li> </ul>"},{"location":"lessons/1_introduction/#algorithms-as-solutions","title":"Algorithms as Solutions","text":"<p>How do we produce that intended output? Algorithms. Algorithms are solutions to computational problems. They take in a possible instance of the problem and are expected to produce a valid output. The process of each algorithm is different but boils down into taking in an input, transforming it, and producing an expected output. The transformation is done using a discrete number of ordered computational steps.</p> <p>In previous courses, you may have been introduced to algorithms as a set of steps that accomplish a certain task. Or you may have used algorithms as backbones for the logic of your code, using them as a means of aiding in the problem solving process. Whether you realized it or not, algorithms are what define programs. All programs are implementations of some algorithm. For example, take a look a the following algorithm for finding the max in a collection of numbers:</p> <ul> <li>Algorithm: Max Element<ul> <li>Inputs: An array \\(A\\) of \\(n\\) numbers \\([ a_0 , a_1, ..., a_{n-1} ]\\), where \\(n &gt; 0\\)</li> <li>Output: \\(a_m\\) the maximum number in the sequence</li> <li>Procedure:<ol> <li>\\(max \\gets A[0]\\)</li> <li>\\(\\text{for } i \\gets 0 \\text{ to } n -1 \\text{ do:}\\)<ol> <li>\\(\\text{if } A[i] &gt; max \\text{ then:}\\)<ol> <li>\\(max \\gets A[i]\\)</li> </ol> </li> <li>\\(\\text{end if}\\)</li> </ol> </li> <li>\\(\\text{end for}\\)</li> <li>\\(\\text{return } max\\)</li> </ol> </li> </ul> </li> </ul> <p>This algorithm could be written in any programming language: <pre><code># Python Max Element\ndef max_element(A):\n    cur_max = A[0] \n\n    for i in range(len(A)):\n        if A[i] &gt; cur_max:\n            cur_max = A[i]\n\n    return cur_max\n</code></pre> <pre><code>// C Max Element\nint max_element(int n, int A[n])\n{\n    int cur_max = A[0];\n\n    for(int i = 0; i &lt; n; i++) {\n        if (A[i] &gt; cur_max) {\n            cur_max = A[i];\n        }\n    }\n\n    return cur_max;\n}\n</code></pre></p> <p>In the pseudo code above, you may notice that the algorithm is defined along with the problem it is meant to solve, showing their relationship.</p>"},{"location":"lessons/1_introduction/#assessing-algorithms","title":"Assessing Algorithms","text":"<p>Say we have the following problem:</p> <ul> <li>Plain English<ul> <li>Linear Search: Find the index of a certain value in an array, return -1 if it does not exist</li> </ul> </li> <li>Formal Definition<ul> <li>Input: <ul> <li>An array \\(A\\) of \\(n\\) numbers \\([ a_0 , a_1, ..., a_{n-1} ]\\), where \\(n &gt; 0\\)</li> <li>Target number \\(t\\)</li> </ul> </li> <li>Output:  The smallest index \\(\\text{i where } A[i]=t, or \u22121\\) if no such index exists</li> </ul> </li> </ul> <p>How would we assess two different algorithms that reportedly solve it?</p> <p>One way would be to check its correctness, or whether or not the algorithm can solve every instance of a problem. Algorithms that halt with the correct output for every input instance are said to be correct and solves the given computational problem. That word \"halt\" refers the requirement that a correct algorithms must terminate in finite time. A correct algorithm cannot sometimes give a correct answer on a given instance, and sometimes run infinitely as a possibility, it must stop.</p> <p>Algorithms can be incorrect and solve only a subset of the possible instances of a computational problem. In these cases, we can assess what percentage of cases the algorithm solves for. While it may seem nonsensical and undesirable to have an algorithm that doesn't always work, there are times it can be beneficial, we will take a look at those at a later date. For the short-term, we will mostly be looking at algorithms that solve certain computational problems completely and are correct. </p> <p>Let's compare the correctness of two algorithms:</p> <ul> <li> <p>Algorithm: 404 Not Found</p> <ul> <li>Input: <ul> <li>An array \\(A\\) of \\(n\\) numbers \\([ a_0 , a_1, ..., a_{n-1} ]\\), where \\(n &gt; 0\\)</li> <li>Target number \\(t\\)</li> </ul> </li> <li>Output: -1</li> <li>Procedure:<ul> <li>\\(\\text{return } -1\\)</li> </ul> </li> </ul> </li> <li> <p>Algorithm: Linear Search</p> <ul> <li>Input: <ul> <li>An array \\(A\\) of \\(n\\) numbers \\([ a_0 , a_1, ..., a_{n-1} ]\\), where \\(n &gt; 0\\)</li> <li>Target number \\(t\\)</li> </ul> </li> <li>Output:  The smallest index \\(\\text{i where } A[i]=t, or \u22121\\) if no such index exists</li> <li>Procedure:<ol> <li>\\(\\text{for } i \\gets 0 \\text{ to } n-1 \\text{ do:}\\)<ol> <li>\\(\\text{if } A[i] = t \\text{ then:}\\)<ol> <li>\\(\\text{return } i\\)</li> </ol> </li> <li>\\(\\text{end if}\\)</li> </ol> </li> <li>\\(\\text{end for}\\)</li> <li>\\(\\text{return } -1\\)</li> </ol> </li> </ul> </li> </ul> <p>Obviously, \"404 Not Found\" is an incomplete algorithm, it always assumes that the target number is not in the input array. For Linear Search, however, we can be pretty sure that it will work for all instances of the problem. There are ways to test this, and we will take a look at those at a later date.</p> <p>Another way to assess an algorithm, is by how fast it runs. While it may not be true 100% of the time, in instances where the target number is not within the input array, \"404 Not Found\" will be faster than \"Linear Search\". </p> <p>No mater what input array given, \"404 Not Found\" will produce an output in a single computational step. If that computational step took 1 second, no matter the size of \\(n\\), or the size of the input array, \"404 Not Found\" will always take 1 second to complete. \"Linear Search\" on the other hand requires many more computational steps to complete. Mainly, it loops through each element of the array until the end in the event of the target not existing. At each iteration of the loop there is a comparison operation, if we take the 1 second time estimate from before then we get a time of \\(n\\) seconds if the target doesn't exist. </p> <p>While this is a simple example, this process can be done on any algorithm and estimate its so called time complexity, a future topic.</p>"},{"location":"lessons/1_introduction/#data-structures","title":"Data Structures","text":"<p>Each of the previous examples works on some form of data. Mostly arrays, or ordered numbers in a set size of contiguous memory. This will be covered more in C Review and later in the data structures lessons, but it means that all data is stored physically next to each other. This creates some limitations with working with it as a medium of data in an algorithm. For example, to remove an element, all elements to the right of it must be shifted down by one in order to fill the empty space left by the removed element. This can be computationally expensive if you are removing and adding elements very quickly to different parts of the array during the run of an algorithm. In other cases, the way you represent the data can make solving problems faster.</p> <p>The way you represent data for a given problem is called the data structure. Data structures are methods of storing and organizing data in some medium that allows for easy access and modification. Choosing the correct data structure has the possibility of trivializing the design of algorithms and the capability to make them for efficient.</p> <p>We will cover many data structures in the course this semester. Some highlights will be:</p> <ul> <li> <p>Arrays and Dynamic Arrays</p> </li> <li> <p>Linked Lists</p> </li> <li> <p>Stacks and Queues</p> </li> <li> <p>Trees</p> </li> <li> <p>Hash tables</p> </li> <li> <p>Graphs</p> </li> </ul> <p>Each one will become a well acquainted tool that you will use to deconstruct and solve problems effectively. In the short term we will be looking at algorithms first, for now, use this section as a means of introducing the idea and begin thinking about how the form of data can lend to problem solving.</p>"},{"location":"lessons/1_introduction/#optional-problems","title":"Optional Problems","text":"<ol> <li> <p>Other than correctness and speed/computational steps, what other ways can we measure the efficiency of an algorithm?</p> </li> <li> <p>Think back to your time with the C programming Language, what were some of the core limitations of it that made it difficult to work with as an early programmer?</p> </li> <li> <p>For each function \\(f(n)\\) and time \\(t\\) in the following table, determine the largest size \\(n\\) of a problem that can be solved in time \\(t\\), assuming that the algorithm to solve the problem takes \\(f(n)\\) microseconds.</p> </li> </ol> 1 second 1 minute 1 hour 1 day 1 month 1 year 1 century \\(\\log n\\) \\(\\sqrt{n}\\) \\(n\\) \\(n \\log n\\) \\(n^2\\) \\(n^3\\) \\(2^n\\) \\(n!\\)"},{"location":"lessons/2_reviewing_c/","title":"C Review","text":"<p>CS 240 is traditionally taught using the C and C++ programming languages. It is expected that you come in with some knowledge of C, on which we will build upon to develop skills in C++. This lesson will serve as a refresher and a reference on C during our early stages of the course</p> <p>This lessons covers:</p> <ul> <li>A general C review</li> <li>Compiled languages</li> <li>C datatypes, both primitive and composite</li> <li>Conditionals and loops</li> <li>The C Pre-Processor</li> <li>and introducing C++</li> </ul>"},{"location":"lessons/2_reviewing_c/#compilation","title":"Compilation","text":"<p>Before recalling the C syntax and semantics, we must first remember the domain we are working in and how programs are ran on a computer system. Computers cannot understand human languages without the power and water supply of a medium-sized town, meaning there must be intermediate steps to running our human-readable code on a computer.</p>"},{"location":"lessons/2_reviewing_c/#compilation-and-interpretation","title":"Compilation and Interpretation","text":"<p>The two main methods of getting a computer to run code are compilation and interpretation. </p> <p>Interpreted languages like Python and JavaScript are executed line-by-line by an interpreter at runtime. When you run a Python script, the interpreter reads each line, translates it to machine instructions, and executes it immediately. This makes development faster since you can test code quickly, but execution tends to be slower since the machine instructions are not always written in the most efficient manner out-of-the-box.</p> <p>Compiled languages, like C and C++, accomplish this task in a different way. Instead of being executed by and interpreter at runtime, C programs are compiled and converted to low-level machine code before runtime. Essentially, compiled languages are translated into machine code at compile time for the target system to produce an executable that can be ran without recompilation or interpretation. This leads to faster programs and more fine-grained control over what happens during the course of your program</p> <p>This process involves four primary steps:</p> <ol> <li>Preprocessing: The C preprocessor (CPP) formats the source code using macros like <code>#include</code> or <code>#define</code>, applying any user-defined changes before passing to the next step</li> <li>Compilation: The compiler translates C source code into assembly language</li> <li>Assembly: The assembler then converts the assembly code into machine code, producing object files, <code>.o</code> or <code>.obj</code>, as a result</li> <li>Linking: The linker orders the object files properly and combines them into a single executable program that is ready to run on the target system</li> </ol> <p>The following are the commands to compile a simple C program, using the GNU C Compiler: <pre><code># Compile source.c into an executable named program\ngcc source.c -o program\n# Run the executable\n./program\n</code></pre> In this simple program, all of the main steps are hidden from the user, however we can use compiler flags to view some of the intermediate files:</p> <ul> <li><code>-E</code>: Stops after preprocessing stage</li> <li><code>-S</code>: Stops compilation after generating assembly code</li> <li><code>-c</code>: Stops compilation after generating object files, preventing linking</li> </ul>"},{"location":"lessons/2_reviewing_c/#basics","title":"Basics","text":"<p>Now that we have reviewed how to compile and run our programs, let's go over the the fundamental building blocks of C programming.</p> <p>The following is a standard \"Hello World!\" program written in C: <pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, const char* argv[])\n{\n    printf(\"Hello CS240!\\n\");\n\n    return 0;\n}\n</code></pre></p> <ol> <li><code>#include &lt;stdio.h&gt;</code> - This is a preprocessor macro to include the <code>stdio.h</code> file at the beginning of this source code file.</li> <li><code>int main(){}</code> - The main function, our main entry point into executing code on the computer. The compiler runs this function in the final executable, making it responsible for orchestrating  all other functions.</li> <li><code>(int argc, const char* argv[])</code> - Command line arguments. When you run the program in the command-line, you may optionally give additional parameters to feed into your program, for example: <code>./program argument1 argument2</code>. <code>argc</code> and <code>argv</code> are variables that contain information about the command-line arguments. <code>argc</code><ol> <li><code>argc</code> - the number of arguments, including the filename of the executable<ol> <li>In the example above, it would take on the value 3</li> </ol> </li> <li><code>argv</code> - an array of char*'s to the actual string parameters passed</li> </ol> </li> <li><code>printf(\"Hello CS240!\\n\");</code> - This line represents a statement in C, an individual line of code. All statements in C must end in a semicolon <code>;</code>. This specific statement is calling a function from <code>stdio.h</code>, <code>printf();</code> which allows the programmer to print information to the screen.</li> <li><code>return 0;</code> - The return statement. When we defined <code>main();</code>, we put an <code>int</code> identifier before the function identifier. This defines the return type that is expected from our function, which is enforced by the compiler. When the return statement is ran the function ends and as will the entire program.  </li> </ol>"},{"location":"lessons/2_reviewing_c/#variables-and-data-types","title":"Variables and Data Types","text":"<p>Variables in C must be declared with a specific type before use. Unlike dynamically typed languages, C requires you to explicitly state what kind of data each variable will hold.</p> <p>The following is an example of declaring variables: <pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, const char* argv[])\n{\n    int num_books = 1000;      // Declaring an int type with a starting value\n    float average_length;      // Declaring a float type without a starting value\n\n\n    return 0;\n}\n</code></pre></p>"},{"location":"lessons/2_reviewing_c/#basic-data-types","title":"Basic Data Types","text":"<p>C provides several primitive data types:</p> <ul> <li>Integer Types: <code>int</code>, <code>short</code>, <code>long</code>, <code>long long</code><ul> <li>Typically <code>int</code> is 4 bytes (32 bits), ranging from -2,147,483,648 to 2,147,483,647</li> <li>Can be modified with <code>unsigned</code> for non-negative values only</li> </ul> </li> <li>Floating-Point Types: <code>float</code>, <code>double</code><ul> <li><code>float</code> is single-precision (4 bytes)</li> <li><code>double</code> is double-precision (8 bytes), preferred for most applications</li> </ul> </li> <li>Character Type: <code>char</code><ul> <li>1 byte, used for characters and small integers</li> <li>Characters are enclosed in single quotes: <code>'A'</code>, <code>'z'</code>, <code>'\\n'</code></li> </ul> </li> <li>Boolean Type: <code>bool</code> with <code>&lt;stdbool.h&gt;</code><ul> <li>Values are <code>true</code> or <code>false</code> Example declarations: <pre><code>int count = 0;\ndouble pi = 3.14159;\nchar grade = 'A';\nunsigned int positive_only = 42;\n</code></pre></li> </ul> </li> </ul>"},{"location":"lessons/2_reviewing_c/#composite-data-types","title":"Composite Data Types","text":"<p>Beyond basic types, C allows you to build more complex data structures:</p> <p>Arrays: Contiguous blocks of memory holding multiple elements of the same type <pre><code>int numbers[5] = {10, 20, 30, 40, 50};\nchar name[20] = \"Alice\";  // Strings are char arrays\n\n// Access elements by index (zero-indexed)\nint first = numbers[0];  // 10\nnumbers[2] = 35;         // Modify third element\n</code></pre> Arrays in C have fixed size and no bounds checking. Accessing an index outside the array's bounds leads to undefined behavior, a common source of bugs.</p> <p>Structures: Group related data of different types <pre><code>struct Student {\n    char name[50];\n    int id;\n    double gpa;\n};\n\nstruct Student alice;\nalice.id = 12345;\nalice.gpa = 3.8;\nstrcpy(alice.name, \"Alice Johnson\");\n</code></pre></p> <p>Pointers: Variables that store memory addresses <pre><code>int value = 42;\nint *ptr = &amp;value;  // ptr stores the address of value\n\nprintf(\"Value: %d\\n\", *ptr);  // Dereference to get value (42)\n*ptr = 100;  // Modify value through pointer\nprintf(\"New value: %d\\n\", value);  // Prints 100\n</code></pre> Pointers are powerful but dangerous. They enable dynamic memory allocation and efficient data manipulation, but incorrect pointer usage causes crashes, memory leaks, and security vulnerabilities.</p>"},{"location":"lessons/2_reviewing_c/#conditionals","title":"Conditionals","text":"<p>Conditionals allow your program to make decisions based on conditions.</p> <p>If-Else Statements <pre><code>int score = 85;\n\nif (score &gt;= 90) {\n    printf(\"Grade: A\\n\");\n} else if (score &gt;= 80) {\n    printf(\"Grade: B\\n\");\n} else if (score &gt;= 70) {\n    printf(\"Grade: C\\n\");\n} else {\n    printf(\"Grade: F\\n\");\n}\n</code></pre></p> <p>Switch Statements: Useful for multiple discrete cases <pre><code>char operation = '+';\nint a = 10, b = 5;\n\nswitch (operation) {\n    case '+':\n        printf(\"Result: %d\\n\", a + b);\n        break;\n    case '-':\n        printf(\"Result: %d\\n\", a - b);\n        break;\n    case '*':\n        printf(\"Result: %d\\n\", a * b);\n        break;\n    default:\n        printf(\"Unknown operation\\n\");\n}\n</code></pre> The <code>break</code> statement is crucial in switch cases to prevent fall-through to subsequent cases.</p>"},{"location":"lessons/2_reviewing_c/#loops","title":"Loops","text":"<p>Loops enable repetition of code blocks.</p> <p>For Loops: Best when the number of iterations is known <pre><code>// Print numbers 0 through 9\nfor (int i = 0; i &lt; 10; i++) {\n    printf(\"%d \", i);\n}\n\n// Iterate through an array\nint arr[5] = {2, 4, 6, 8, 10};\nfor (int i = 0; i &lt; 5; i++) {\n    printf(\"%d \", arr[i]);\n}\n</code></pre></p> <p>While Loops: Best when the number of iterations is unknown <pre><code>int count = 0;\nwhile (count &lt; 5) {\n    printf(\"Count: %d\\n\", count);\n    count++;\n}\n</code></pre></p> <p>Do-While Loops: Execute at least once, then check condition <pre><code>int input;\ndo {\n    printf(\"Enter a positive number: \");\n    scanf(\"%d\", &amp;input);\n} while (input &lt;= 0);\n</code></pre></p>"},{"location":"lessons/2_reviewing_c/#the-c-pre-processor-cpp","title":"The C Pre-Processor (CPP)","text":"<p>The C preprocessor runs before compilation and handles directives that begin with <code>#</code>. These directives modify your source code before it's compiled.</p> <p>Include Directive: Imports header files <pre><code>#include &lt;stdio.h&gt;   // System header (standard library)\n#include \"myheader.h\"  // User-defined header (local file)\n</code></pre></p> <p>Define Directive: Creates macros and constants <pre><code>#define PI 3.14159\n#define MAX_SIZE 100\n#define SQUARE(x) ((x) * (x))\n\n// Usage\ndouble area = PI * SQUARE(radius);\n</code></pre> Macros are simple text replacements. Notice the parentheses in <code>SQUARE(x)</code> to avoid unexpected behavior with operator precedence.</p> <p>Conditional Compilation: Include or exclude code based on conditions <pre><code>#define DEBUG\n\n#ifdef DEBUG\n    printf(\"Debug: x = %d\\n\", x);\n#endif\n\n#ifndef MAX_VALUE\n    #define MAX_VALUE 1000\n#endif\n</code></pre> This is useful for platform-specific code or enabling debug output during development.</p>"},{"location":"lessons/2_reviewing_c/#file-io-in-c","title":"File I/O in C","text":"<p>Programs often need to read from and write to files for persistent data storage. C provides a standard library interface for file operations through <code>&lt;stdio.h&gt;</code>.</p>"},{"location":"lessons/2_reviewing_c/#opening-and-closing-files","title":"Opening and Closing Files","text":"<p>Before reading or writing, you must open a file using <code>fopen()</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");  // Open for reading\n\n    if (file == NULL) {\n        printf(\"Error: Could not open file\\n\");\n        return 1;\n    }\n\n    // Use the file...\n\n    fclose(file);  // Always close when done\n    return 0;\n}\n</code></pre> <p>File modes determine how the file is accessed:</p> <ul> <li><code>\"r\"</code> - Read mode (file must exist)</li> <li><code>\"w\"</code> - Write mode (creates new file or overwrites existing)</li> <li><code>\"a\"</code> - Append mode (writes to end of file)</li> <li><code>\"r+\"</code> - Read and write (file must exist)</li> <li><code>\"w+\"</code> - Read and write (overwrites existing file)</li> <li><code>\"a+\"</code> - Read and append</li> </ul> <p>Always check if <code>fopen()</code> returns <code>NULL</code>, which indicates the file couldn't be opened. Common reasons include the file not existing (for read mode) or lacking permissions.</p>"},{"location":"lessons/2_reviewing_c/#reading-from-files","title":"Reading from Files","text":"<p>Character by character:</p> <pre><code>FILE *file = fopen(\"input.txt\", \"r\");\nchar ch;\n\nwhile ((ch = fgetc(file)) != EOF) {\n    printf(\"%c\", ch);\n}\n\nfclose(file);\n</code></pre> <p>Line by line:</p> <pre><code>FILE *file = fopen(\"input.txt\", \"r\");\nchar line[256];\n\nwhile (fgets(line, sizeof(line), file) != NULL) {\n    printf(\"%s\", line);\n}\n\nfclose(file);\n</code></pre> <p><code>fgets()</code> reads up to <code>n-1</code> characters or until a newline, whichever comes first. The newline character is included in the string if encountered.</p> <p>Formatted input:</p> <pre><code>FILE *file = fopen(\"scores.txt\", \"r\");\nchar name[50];\nint score;\n\nwhile (fscanf(file, \"%s %d\", name, &amp;score) == 2) {\n    printf(\"%s scored %d\\n\", name, score);\n}\n\nfclose(file);\n</code></pre> <p><code>fscanf()</code> works like <code>scanf()</code> but reads from a file instead of standard input. It returns the number of items successfully read.</p>"},{"location":"lessons/2_reviewing_c/#writing-to-files","title":"Writing to Files","text":"<p>Character by character:</p> <pre><code>FILE *file = fopen(\"output.txt\", \"w\");\n\nfputc('H', file);\nfputc('i', file);\nfputc('\\n', file);\n\nfclose(file);\n</code></pre> <p>Strings:</p> <pre><code>FILE *file = fopen(\"output.txt\", \"w\");\n\nfputs(\"Hello, World!\\n\", file);\nfputs(\"Writing to a file.\\n\", file);\n\nfclose(file);\n</code></pre> <p>Formatted output:</p> <pre><code>FILE *file = fopen(\"results.txt\", \"w\");\n\nfprintf(file, \"Student: %s\\n\", \"Alice\");\nfprintf(file, \"Score: %d\\n\", 95);\nfprintf(file, \"GPA: %.2f\\n\", 3.87);\n\nfclose(file);\n</code></pre> <p><code>fprintf()</code> works like <code>printf()</code> but writes to a file instead of standard output.</p>"},{"location":"lessons/2_reviewing_c/#practical-example","title":"Practical Example","text":"<p>Here's a complete program that reads student data from a file and calculates the average score:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    FILE *input = fopen(\"students.txt\", \"r\");\n    if (input == NULL) {\n        printf(\"Error opening input file\\n\");\n        return 1;\n    }\n\n    char name[50];\n    int score;\n    int total = 0;\n    int count = 0;\n\n    while (fscanf(input, \"%s %d\", name, &amp;score) == 2) {\n        printf(\"%s: %d\\n\", name, score);\n        total += score;\n        count++;\n    }\n\n    fclose(input);\n\n    if (count &gt; 0) {\n        double average = (double)total / count;\n\n        FILE *output = fopen(\"summary.txt\", \"w\");\n        fprintf(output, \"Total students: %d\\n\", count);\n        fprintf(output, \"Average score: %.2f\\n\", average);\n        fclose(output);\n\n        printf(\"\\nSummary written to summary.txt\\n\");\n    }\n\n    return 0;\n}\n</code></pre> <p>Remember: always close files with <code>fclose()</code> when finished. Failing to do so can result in data loss or resource leaks. The file pointer (<code>FILE *</code>) keeps track of your position in the file and manages buffering for efficient I/O operations.</p>"},{"location":"lessons/2_reviewing_c/#c-and-c","title":"C and C++","text":"<p>While this course uses both C and C++, it's important to understand their relationship.</p> <p>C++ was developed as an extension of C, adding features like classes, objects, templates, and exceptions while maintaining most of C's syntax. This means valid C code is often valid C++ code, but not always.</p> <p>The following are some immediate differences you'll have to work around.</p> <p>Function Declarations: C++ requires function prototypes before use; C is more lenient</p> <p>Input/Output: C++ introduces <code>iostream</code> with <code>cin</code> and <code>cout</code>, though C's <code>printf</code> and <code>scanf</code> still work</p> <p>Type Safety: C++ is stricter about type conversions <pre><code>// Valid in C, error in C++\nint *ptr = malloc(sizeof(int));  \n\n// C++ requires explicit cast\nint *ptr = (int*)malloc(sizeof(int));\n\n// Better: use C++ new operator\nint *ptr = new int;\n</code></pre></p> <p>As we progress through the course, we'll build on your C foundation to explore C++'s object-oriented features, which provide powerful tools for organizing complex programs and implementing sophisticated data structures.</p> <p>For now, ensure you're comfortable with these C fundamentals. They form the basis for everything we'll build in the coming weeks and we will explore more deeply on these differences later.</p>"},{"location":"lessons/3_runtime/","title":"Runtime Analysis Fundamentals","text":"<p>Why do some programs feel fast while others make us want to throw our computers out the window? Why does sorting 100 items take milliseconds but sorting 100,000 items takes minutes? The answer lies in understanding how algorithms scale.</p> <p>In this lesson, we'll develop a mathematical framework for measuring runtime that works regardless of what computer you're using or what programming language you choose.</p> <p>This lesson covers how to:</p> <ul> <li>Explain why we can't just time algorithms to compare them</li> <li>Construct a runtime function T(n) for simple algorithms</li> <li>Identify the dominant components that drive runtime growth</li> <li>Recognize common patterns of growth (linear, quadratic, logarithmic, etc.)</li> <li>Predict which of two algorithms will be faster for large inputs</li> </ul>"},{"location":"lessons/3_runtime/#algorithms","title":"Algorithms","text":"<p>To review briefly:</p> <ul> <li>Computational problems are formal definitions of problems that outline the intended input and the desired output</li> <li>Algorithms are solutions to computational problems that use a finite number of sequential steps to go from input to desired output</li> <li>Programs are implementations of algorithms </li> <li>The most basic way to assess an algorithm is to measure how many of the possible inputs can be solved using it, if it solves all problem instances, it is said to be correct. It is incorrect if it does not solve for one or more instances of the problem space</li> </ul> <p>Now that the background is laid, we need to consider other ways of assessing algorithms, especially in terms that relate to programs and the domain we are solving in, digital computers. When speaking about modern computers, there are two basic attributes that dictate how good a computer is viewed in the modern day:</p> <ul> <li>Execution Speed: How fast operations are being executed</li> <li>Memory Size: How much space do we have to store information</li> </ul> <p>In the same light, we assess the programs we use in these terms too. If a program is too slow, or uses too much RAM, we do not like it and identify it as a problem. Computers have gotten so good that we assume that all algorithms/programs are correct, it is just a matter of speed and resources. </p> <p>Correctness Going Forward</p> <p>While correctness is probably the most important metric we could measure from an algorithm, we will always be attempting to make algorithms completely correct by default. This shifts the focus to those two attributes above. In fact, in most formal definitions algorithms are assumed to be correct. This lead to the division between deterministic algorithms; algorithms that have completely predicable behavior, always producing the same, correct output for any given input. And probabilistic algorithms; algorithms that use randomness in their execution, which means their correctness, runtime, or memory usage may vary between runs even with identical inputs. We mainly focus on pure, correct, deterministic algorithms, but by the end of the semester we will see some probabilistic algorithms.</p>"},{"location":"lessons/3_runtime/#input-size","title":"Input Size","text":"<p>With this in mind, how do we measure the time an algorithm takes or how much memory it takes up? To begin to tackle this, we should identify that the size of the input matters a lot for both of these metrics.</p> <p>Input size depends on the problem being solved. For the problems we covered before like search, finding a max, or sorting, the input size is the amount of items in the input array/list. Take the finding max example from before:</p> <ul> <li>Algorithm: Max Element<ul> <li>Inputs: An array \\(A\\) of \\(n\\) numbers \\([ a_0 , a_1, ..., a_{n-1} ]\\), where \\(n &gt; 0\\)</li> <li>Output: \\(a_m\\) the maximum number in the sequence</li> <li>Procedure:<ol> <li>\\(max \\gets A[0]\\)</li> <li>\\(\\text{for } i \\gets 0 \\text{ to } n -1 \\text{ do:}\\)<ol> <li>\\(\\text{if } A[i] &gt; max \\text{ then:}\\)<ol> <li>\\(max \\gets A[i]\\)</li> </ol> </li> <li>\\(\\text{end if}\\)</li> </ol> </li> <li>\\(\\text{end for}\\)</li> <li>\\(\\text{return } max\\)</li> </ol> </li> </ul> </li> </ul> <p>Here the input size is denoted with \\(n\\), as \\(n\\) increases, the algorithm will need to run more times, since its for loop is bounded by \\(n-1\\).  However, input size does not need to be connected to the number of elements in an array, it could be the size of the numbers coming in, take the following algorithm for two binary numbers being added: </p> <ul> <li>Algorithm: Binary Addition <ul> <li>Inputs: Two binary numbers \\(A\\) and \\(B\\) of \\(n\\) bits each, \\(A = [a_{n-1}, a_{n-2}, ..., a_0]\\) and \\(B = [b_{n-1}, b_{n-2}, ..., b_0]\\) </li> <li>Output: Binary number \\(C\\) representing \\(A + B\\) </li> <li>Procedure: <ol> <li>\\(carry \\gets 0\\) </li> <li>\\(C \\gets \\text{empty array of size } n+1\\) </li> <li>\\(\\text{for } i \\gets 0 \\text{ to } n-1 \\text{ do:}\\) <ol> <li>\\(sum \\gets a_i + b_i + carry\\) </li> <li>\\(C[i] \\gets sum \\mod 2\\) </li> <li>\\(carry \\gets \\lfloor sum / 2 \\rfloor\\) </li> </ol> </li> <li>\\(\\text{end for}\\) </li> <li>\\(C[n] \\gets carry\\) </li> <li>\\(\\text{return } C\\)</li> </ol> </li> </ul> </li> </ul> <p>Here we add two numbers always, but their sizes deem how long the algorithm runs. So its not always about lists or collections alone, but the size of the data being represented.</p>"},{"location":"lessons/3_runtime/#runtime-of-algorithms","title":"Runtime of Algorithms","text":"<p>We keep talking about the amount of time it takes an algorithm to run or if an algorithm is slow or fast, how can we measure that? Is it just the time it takes for the program implementing an algorithm to run on some computer? Let's test this, say we have two programs that implement the same algorithm and are given the same input. Further imagine that we have Computer A and Computer B. If we run both programs on Computer A, they will take the same amount of time to run, lets say 5 microseconds. We then move one copy of the program to Computer B and then race the two computers running the same program on the same input as before. We get the following results: </p> <ul> <li>Results<ul> <li>Program on Computer A = 5 microseconds</li> <li>Program on Computer B = 10 microseconds</li> </ul> </li> </ul> <p>Without knowing about the specs of A or B, we can see that B probably is a worse computer. However, which number would we use as the runtime for our algorithm given the input? What would happen if we programmed them in a different language that sped up or slowed down the program?</p> <p>These questions are the reason why the runtime of an algorithm is not usually measured using the physical time it takes for an algorithm to generate an output for a given input. It is completely dependent on the implementation of the algorithm and where it is being ran, which makes it not the best metric for these abstract, almost universal algorithms. </p> <p>To attend to this nature, the runtime (or running time) of an algorithm on a particular input is measured using the number of primitive operations or \"steps\" executed. These primitive operations are meant to be machine-independent and assumed they all take a constant amount of time. For us, this means we assume that each line of pseudocode of an algorithm takes a constant amount of time for a hypothetical computer to accomplish, lets call the amount of time \\(c\\). Some lines of the pseudocode may take longer than others, so lets say that \\(c_i\\) is the constant amount of time it takes for line number \\(i\\) of pseudocode to run. </p> <p>Using this notation we can develop an equation to measure the amount of time it takes for an algorithm to run. The following is an exercise in breaking down the Max-Element Algorithm from before. Note that, we will not be doing this entire process for every algorithm we want to compare (it gets messy), but we will use it to derive a more general and simple process for estimating the run time of an algorithm.</p> <p>Here is the algorithm from before with the amount of time each line it takes and the number of times that line will be run labeled with it:</p> No. Step \\(c_i\\) Number of Times 1 \\(max \\gets A[0]\\) \\(c_1\\) 1 2 \\(\\text{for } i \\gets 0 \\text{ to } n -1 \\text{ do:}\\) \\(c_2\\) \\(n+1\\) 3 \\(\\text{if } A[i] &gt; max \\text{ then:}\\) \\(c_3\\) \\(n\\) 4 \\(max \\gets A[i]\\) \\(c_4\\) \\([0,n]\\) 5 \\(\\text{end if}\\) 0 \\(n\\) 6 \\(\\text{end for}\\) 0 \\(n+1\\) 7 \\(\\text{return } max\\) \\(c_7\\) 1 <p>Some things worth to mention before moving on:</p> <ul> <li>Notice that steps that are not within a loop are ran only once</li> <li>The for loop is ran \\(n+1\\) times but its contents run \\(n\\) times because the \\(for\\) loop is evaluating until the condition is found to be false, meaning it will run \\(n\\) times and then check its exit condition, adding another operation.</li> <li>The if statement is checked each time the loop is ran, but its contents could run anywhere between \\(0\\) and \\(n\\) times. This is because depending on the input, it might not be ran (if the max is the first element) or it will be ran each iteration (the list is sorted and the final element is max). The range lower bound gives us the best case and the upper bound gives us the worst case.</li> <li>The \\(end\\) statements do not actually cost any time, these are just notations for pseudocode and can be omitted most times. </li> </ul> <p>To get the amount of time each operation takes for an input of size \\(n\\) id quite easy, just multiply the constant time it takes to run that line and the number of times it will be ran based on \\(n\\):</p> <ul> <li>Step 1: \\((c_1)(1) = c_1\\)<ul> <li>This makes sense since this step is always ran once, never more or less, so it is always going to take this line \\(c_1\\) amount of time no matter the input.</li> </ul> </li> <li>Step 2: \\((c_2)(n+1) = c_2n+c_2\\)<ul> <li>So for a size 4 input array: \\(c_2(4) + c_2 = 5c_2\\) because the loop will go through each element and then at the end check one more time for the exit condition.</li> </ul> </li> </ul> <p>If we wanted to continue this and find the amount of time the entire algorithm takes for an input of size \\(n\\), denoted as \\(T(n)\\), we would just take the sum of each step's time cost and number of times ran. Note, since step 4 has a variable number of times ran, we will calculate its worst-case scenario runtime:</p> <ul> <li>\\(T(n)=c_1(1) + c_2(n+1) + c_3(n) + c_4(n) + c_7(1)\\)</li> </ul> <p>After some simplification:</p> <ul> <li>\\(T(n)=c_1 + c_2(n+1) + c_3n + c_4n + c_7\\)</li> <li>\\(T(n)=c_1 + c_2n + c_2 + c_3n + c_4n + c_7\\)</li> <li>\\(T(n)= (c_2 + c_3 + c_4)n + (c_1 + c_2 + c_7)\\)</li> </ul> <p>Here we can see that if we make \\(a = c_2 + c_3 + c_4\\) and \\(b=c_1 + c_2 + c_7\\), then we can simplify again to see: \\(T(n)=an+b\\). Since \\(a\\) and \\(b\\) are sums of constants, they are constants themselves, making the running time able to be expressed using a linear function of \\(n\\). </p> <p>Linear functions are the basic \\(y=mx+b\\) form of functions that describe a constant growth of \\(m\\) offset by \\(b\\) for a changing value of \\(x\\). We are saying here that as the size of the input, \\(n\\), grows, the runtime of the algorithm grows at a constant rate. Say that the sum of \\(a\\) is 4 milliseconds and \\(b\\) is 5 milliseconds and we evaluate the worst-case scenario for arrays of sizes 1 - 5:</p> <p></p> \\(n\\) \\(T(n)=4n+5\\) 1 9 2 13 3 17 4 21 5 25 <p> We can see this constant growth by the addition of 4 at each increment of \\(n\\), as well as by the straight line with a constant slope. Note that this is the worst-case scenario where we assumed that it would take the maximum number of steps possible. If we did the best-case, it would still be a linear line although the slope component \\(a\\) would have \\(c_4\\) removed, and make it a slightly slower linear growth (meaning it will be faster for all values of \\(n\\)). Most of the time we will measure the worst-case of an algorithm, so as to always have a maximum of how long the algorithm could take to run.</p> <p>The following is another example of breaking down an algorithm that checks if an array contains any duplicate values. Note this is another messy bit of math, focus less on the specifics of the math and more the intuition that it leads to; different algorithms have different runtimes as \\(n\\) grows:</p> <ul> <li>Algorithm: Contains Duplicates<ul> <li>Input: An array \\(A\\) of \\(n\\) numbers \\([a_0, a_1, ..., a_{n-1}]\\)</li> <li>Output: <code>true</code> if there are duplicates, <code>false</code> otherwise</li> <li>Procedure:</li> </ul> </li> </ul> No. Step \\(c_i\\) Number of Times 1 \\(\\text{for } i \\gets 0 \\text{ to } n-1 \\text{ do:}\\) \\(c_1\\) \\(n+1\\) 2 \\(\\text{for } j \\gets i+1 \\text{ to } n-1 \\text{ do:}\\) \\(c_2\\) \\(\\sum_{i=0}^{n-1}(n-i)\\) 3 \\(\\text{if } A[i] = A[j] \\text{ then:}\\) \\(c_3\\) \\(\\sum_{i=0}^{n-1}(n-i-1)\\) 4 \\(\\text{return true}\\) \\(c_4\\) \\([0,1]\\) 5 \\(\\text{end if}\\) 0 - 6 \\(\\text{end for}\\) 0 - 7 \\(\\text{end for}\\) 0 - 8 \\(\\text{return false}\\) \\(c_8\\) 1 <ul> <li>The outer loop runs \\(n\\) times (checking the exit condition \\(n+1\\) times)</li> <li>For each iteration \\(i\\) of the outer loop, the inner loop runs \\((n-i-1)\\) times</li> <li>In the worst case (no duplicates found), we check every pair of elements</li> </ul> <p>Calculating the worst-case runtime:</p> <p>For the inner loop iterations across all outer loop iterations (simplifying using arithmetic series math):</p> \\[\\sum_{i=0}^{n-1}(n-i-1) = (n-1) + (n-2) + (n-3) + ... + 1 + 0 = \\frac{n(n-1)}{2}\\] <p>So our total runtime is after plugging in the previous:</p> \\[T(n) = c_1(n+1) + c_2\\left(\\frac{n(n-1)}{2}\\right) + c_3\\left(\\frac{n(n-1)}{2}\\right) + c_8\\] <p>Simplifying:</p> \\[T(n) = c_1n + c_1 + \\frac{c_2n^2 - c_2n}{2} + \\frac{c_3n^2 - c_3n}{2} + c_8\\] \\[T(n) = \\frac{(c_2+c_3)}{2}n^2 + \\left(c_1 - \\frac{c_2+c_3}{2}\\right)n + (c_1 + c_8)\\] <p>If we let \\(a = \\frac{c_2+c_3}{2}\\), \\(b = c_1 - \\frac{c_2+c_3}{2}\\), and \\(c = c_1 + c_8\\), we get:</p> \\[T(n) = an^2 + bn + c\\] <p>This is a quadratic function, one that forms a parabola with quadratic growth/decay on the arms. Let's see how this compares to our linear Max-Element algorithm.</p> <p>Assuming \\(a = 2\\) ms, \\(b = 1\\) ms, and \\(c = 3\\) ms:</p> \\(n\\) Linear: \\(4n+5\\) Linear Change Quadratic: \\(2n^2+n+3\\) Quadratic change 1 9 - 6 - 2 13 +4 13 +7 3 17 +4 24 +11 4 21 +4 39 +15 5 25 +4 58 +19 6 29 +4 81 +23 7 33 +4 108 +27 <p></p> <p>Notice that this algorithm has an increasing rate of change that makes it take significantly more time as the size of the input grows. This growth is quadratic from the \\(n^2\\) part of the time equation, this is called the dominant component and is the main contributor to the increasing rate of change and high total runtime the algorithm takes on a given input. If we wanted to understand generally about how an algorithm behaves on increasing input sizes, we could focus on this part and ignore the rest.</p> <p> </p>"},{"location":"lessons/3_runtime/#growth-of-functions","title":"Growth of Functions","text":"<p>In the previous section, we saw how we can examine an algorithm and estimate its runtime generally and machine-independently. After getting the time function, \\(T(n)\\), for two algorithms, we saw that different algorithms take much longer than others as the input grows. In order to get there we had to do some simplifications. </p> <p>One was that we abstracted the cost of each line of pseudocode into a single value \\(c_i\\). We then further simplified things down by taking groups of constants operating on one another (the creation of \\(a\\) and \\(b\\) in the Max Example). This shows that the constants individually can usually be ignored and abstracted into further mathematical constants that can be calculated for each implementation of the algorithm. Components like \\(n\\) or \\(n^2\\) are the important parts, everything else is machine dependent.</p> <p>Continuing that idea, the dominate components that dictate how the function grows as \\(n\\) increases should be the main focus of the analysis of an algorithm. For example, the linear growth of the Max Algorithm, represented using \\(T(n) = an+b\\), \\(a\\) and \\(b\\) can be completely ignored until later. It is the \\(n\\) part that informs the nature of how the function grows. Take the following graph as an example.</p> <p>Here, we have the quadratic growth \\(n^2\\) graphed along with various linear functions with different slopes:</p> <p></p> <p>Because quadratic growth has a ever-increasing rate of change, it will always overtake linear growth for some value of \\(n\\), regardless of what constants are taken in account for the calculation. There are a few main types of growth we will be worrying about in this course:</p> <ul> <li>Constant Value: \\(c\\)<ul> <li>There is no growth to the function, it will always output constant \\(c\\)</li> </ul> </li> <li>Linear Growth : \\(n\\)<ul> <li>Rate of change is constant</li> </ul> </li> <li>Quadratic Growth : \\(n^c\\)<ul> <li>Rate of change increases by a constant rate \\(c\\)</li> </ul> </li> <li>Exponential Growth : \\(c^n\\)<ul> <li>Rate of change increases by an increasing rate</li> </ul> </li> <li>Logarithmic Growth : \\(log(n)\\)<ul> <li>Growth is determined by the log function</li> </ul> </li> <li>Log-Linear Growth : \\(nlog(n)\\)<ul> <li>The result of doing \\(log(n)\\), \\(n\\) times. Growth is a mix of linear and logarithmic growth. For small values of \\(n\\), log-linear is faster that linear, but as \\(n\\) gets larger it overtakes linear.</li> </ul> </li> </ul> <p>Here is a graph with all of them:</p> <p></p> <p>As you can see the different functions all increase at different rates as \\(n\\), the input size, increases. These represent the growth that any function can take, however, here each represents a function that describes how runtime increases as the size of the input for an algorithm increases. From here we can see that it is not the individual runtimes of instances that matter when assessing an algorithm, it is the pattern of the growth of runtime as the input size increases. </p>"},{"location":"lessons/4_big_o/","title":"Asymptotic Notation: Big O and Beyond","text":"<p>You've learned how to measure algorithm runtime by constructing T(n) functions and identifying dominant components. But writing out the full derivations every time is impractical. We need shorthand.</p> <p>Asymptotic notation is the language computer scientists use to describe algorithm efficiency in a short way. It ignores the constants from before and focuses on the dominant components to explain an algorithms behavior and how it scales to larger inputs.</p> <p>The three most important asymptotic notations are:</p> <ul> <li>Big O (O) - Upper bound (worst-case): \"It will never be slower than this\"</li> <li>Big Omega (\u03a9) - Lower bound (best-case): \"It can't be faster than this\"</li> <li>Big Theta (\u0398) - Tight bound (average-case): \"It grows exactly like this\"</li> </ul> <p>This lesson covers how to:</p> <ul> <li>Express algorithm runtime using Big O, Omega, and Theta notation</li> <li>Analyze both best-case and worst-case scenarios for the same algorithm</li> <li>Quickly compare algorithms by their complexity classes</li> <li>Find dominant components in code without exhaustive mathematical analysis</li> <li>Understand why a \"slower-looking\" O(n log n) algorithm often beats a \"simple\" O(n\u00b2) one</li> </ul>"},{"location":"lessons/4_big_o/#asymptotic-notation","title":"Asymptotic Notation","text":"<p>From the last lesson , we now see that:</p> <ul> <li>Algorithms take a certain number of discrete steps for a given problem instance</li> <li>Those steps take some amount of time when implemented on hardware</li> <li>The total number of steps is ultimately decided by the input size \\(n\\)</li> <li>We can estimate the runtime of an algorithm by constructing a \\(T(n)\\) function in terms of its input size, \\(n\\), and how many times each step is ran based on \\(n\\). We then multiply each step by hypothetical constants, \\(c_i\\), corresponding to algorithm step \\(i\\).</li> <li>Some algorithms runtimes grow faster than others, and this is largely decided by the equations that use \\(n\\), called the dominant component and it dictates an algorithms rate of growth</li> </ul> <p>This dominant component and rate of growth is what really matters. In the \"Growth of Functions\" section, we saw that no matter what constant values a linear growth function has, it will always result in a lower rate of growth than a quadratic function. For this reason, we can ignore constants for the most part and measure an algorithms run time as the dominant component:</p> <ul> <li>Max Algorithm: <ul> <li>\\(T(n)= (c_2 + c_3 + c_4)n + (c_1 + c_2 + c_7) \\approx n\\)</li> </ul> </li> <li>Find Duplicates Algorithm: <ul> <li>\\(T(n) = \\frac{(c_2+c_3)}{2}n^2 + \\left(c_1 - \\frac{c_2+c_3}{2}\\right)n + (c_1 + c_8) \\approx n^2\\)</li> </ul> </li> <li>Both in terms of rate of growth of run time</li> </ul> <p>This is called asymptotic notation and it refers to the discarding of lower order terms (lower rate of growth terms) and constants. We use it in reference to runtimes to calculate an algorithms time complexity, or how the algorithm's runtime increases as the input size grows under various conditions. </p> <p>Recall that, when we constructed \\(T(n)\\), the runtime function of an algorithm, there was a mention of a worst-case and best-case runtime when calculating an indeterminant number of steps depending on the contents of the input rather than its size. </p> <p>Worst-case refers to the maximum number of steps an algorithm could take if the input was the hardest it could be to solve. For the Max Algorithm, if the input was sorted least-greatest, line 4 would get ran \\(n\\) times, where as if the max value was in the beginning, line 4 would never be ran.  This latter situation is the best-case scenario, where every line takes the least number of steps possible. Another example of this would be the Sorting Problem, any sorting problem's best-case scenario is an input that is fully sorted. There is also average-case where an average input in size and difficulty is assumed or calculated and that is used to find the average running time of an algorithm.</p> <p>Each one of these is useful for understanding and assessing algorithms. Especially when you consider the fact that dominant components may be different for worst, best, and average cases. This means we have three options to assess an algorithm, and, as a result, three types of asymptotic notation:</p> <ul> <li>\\(\\Theta (g(n))\\) - \"Big Theta\" Notation</li> <li>\\(\\Omega (g(n))\\) - \"Big Omega\" Notation</li> <li>\\(O(g(n))\\) - \"Big O\" Notation</li> </ul>"},{"location":"lessons/4_big_o/#big-theta-notation","title":"Big Theta Notation","text":"<p>\\(\\Theta (g(n))\\) - \"Big Theta\" Notation</p> <p>For a given function \\(g(n)\\), we denote by \\(\\Theta (g(n))\\) the set of functions</p> \\[\\begin{gather}\\Theta (g(n)) = \\{f(n): \\text{there exist positive constants } c_1, c_2, \\text{and } n_0 \\text{ such that}\\\\ 0 \\leq c_1 g(n) \\leq f(n) \\leq c_2g(n) \\text{ for all } n \\geq n_0 \\}\\end{gather}\\] <ul> <li>This means the function grows at exactly this \\(g(n)\\) - it's sandwiched between the upper and lower bound of constants for all values of \\(n\\) starting at some \\(n_0\\) </li> <li>We use Big Theta when we can describe the average-case or when the worst and best cases are the same of an algorithm</li> <li>Example: The Max Algorithm is  \\(\\Theta (n)\\) because it always does roughly \\(n\\) comparisons regardless of the input</li> </ul> <p>Big Theta is used to show an algorithms average-case or true runtime growth. If an algorithm's \"average input\" can be assumed or derived probabilistic analysis of the algorithm over many different inputs could be used to find its average-case. Most of the time, the average-case is found through experimentation or assumed through rough estimates. Otherwise we use Big Theta when the upper and lower limit of growth is the same.</p>"},{"location":"lessons/4_big_o/#big-omega-notation","title":"Big Omega Notation","text":"<p>\\(\\Omega (g(n))\\) - \"Big Omega\" Notation</p> <p>For a given function \\(g(n)\\), we denote by \\(\\Omega (g(n))\\) the set of functions</p> \\[\\begin{gather}\\Omega (g(n)) = \\{f(n): \\text{there exist positive constants } c \\text{ and } n_0 \\text{ such that}\\\\ 0 \\leq c g(n) \\leq f(n) \\text{ for all } n \\geq n_0 \\}\\end{gather}\\] <ul> <li>This means the function grows at least at a rate of \\(g(n)\\), but it can be higher than this lower bound</li> <li>We use Big Omega when we can describe the best-case of an algorithm and know that the runtime function cannot grow slower than \\(g(n)\\) </li> </ul> <p>Big Omega notation is the asymptotic lower bound and describes the best-case running time of an algorithm. What ever function of growth \\(g(n)\\) has, it represents the runtime growth of an algorithm as the ideal input grows. It represented the fastest an algorithm can go, given an input that results in the fewest steps where there are varying numbers of them. </p>"},{"location":"lessons/4_big_o/#big-o-notation","title":"Big O Notation","text":"<p>\\(O(g(n))\\) - \"Big O\" Notation</p> <p>For a given function \\(g(n)\\), we denote by \\(O (g(n))\\) the set of functions</p> \\[\\begin{gather}O (g(n)) = \\{f(n): \\text{there exist positive constants } c \\text{ and } n_0 \\text{ such that}\\\\ 0  \\leq f(n) \\leq c g(n) \\text{ for all } n \\geq n_0 \\}\\end{gather}\\] <ul> <li>This means the function grows at most at a rate of \\(g(n)\\), but it can be lower than this upper bound</li> <li>We use Big O when we want to describe the worst-case of an algorithm and know that the runtime function will be at worst growing at rate \\(g(n)\\)</li> <li>We are usually going to talk about this one since the worst-case is usually the most important to work around in critical places</li> </ul> <p>Big O Notation is the most used notation as it is used to describe the worst-case running time growth. This represents the asymptotic upper bound and defines the upper limit of growth in the runtime of an algorithm. It assumes inputs that cause the maximum number of steps and represents the worst possible performance of the algorithm as input grows. As such, it is the most useful of the three, since we often need to plan around the worst case scenario in safety critical environments. </p>"},{"location":"lessons/4_big_o/#time-complexity","title":"Time Complexity","text":"<p>These various notations allow us to describe the behavior of an algorithm's runtime as the size of the input grows, this is known as the time complexity of the algorithm, and we use the three methods above to describe the general growth of the runtime function \\(T(n)\\) under different conditions. We will, for the most part, focus on using asymptotic notation to describe how runtime grows, however we can use it to describe the growth of any function. The other resource we will want to describe using this method is the amount of memory an algorithm requires. This space complexity, will be highlighted another day, but know that we can use this notation for other things.</p> <p>To show the full break down of an algorithm, read through this lab that shows the process of estimating a runtime function, discarding constants, and extracting dominant components to generate the various time complexity metrics for Insertion Sort.</p>"},{"location":"lessons/4_big_o/#o-my-gosh-so-complex","title":"\"O\" My Gosh... So \"Complex\"...","text":"<p>This may have been a bit jarring with the math and the notation if you are not used to it. While these ideas were sprung from years of complex mathematical theory, we do not need to focus on it in this class. This is merely an introduction to algorithmic analysis and to familiarize oneself with the various ways we would assess an algorithm, complex as a task as it may seem.</p> <p>One of the consequences of going down the path of mathematical theory is a loss of practical use. To ensure our perspective remains properly oriented, it would be best to review these various ideas and connect them to things we can use in our coding.</p>"},{"location":"lessons/4_big_o/#quick-algorithm-assessment","title":"Quick Algorithm Assessment","text":"<p>Because computer science has matured as much as it has, many times when we approach a problem there will already be a suite of solutions available to choose from, each with their complexity listed out beforehand. One such problem that will reoccur in this course is the Sorting Problem. We will cover the Sorting Problem and all of these algorithms in depth another day, but let's put our newly found knowledge to use. </p> Algorithm Best Case Average Case Worst Case Space Complexity Bubble Sort \\(\\Omega(n)\\) \\(\\Theta(n\u00b2)\\) \\(O(n\u00b2)\\) \\(\\Theta(1)\\) Selection Sort \\(\\Omega(n\u00b2)\\) \\(\\Theta(n\u00b2)\\) \\(O(n\u00b2)\\) \\(\\Theta(1)\\) Insertion Sort \\(\\Omega(n)\\) \\(\\Theta(n\u00b2)\\) \\(O(n\u00b2)\\) \\(\\Theta(1)\\) Merge Sort \\(\\Omega(n log n)\\) \\(\\Theta(n log n)\\) \\(O(n log n)\\) \\(O(n)\\) <p>To aid in this quick assessment, it will help to bring in the graph from the Runtime Lesson:</p> <p></p> <p>Looking at this graph and the table above, it makes the comparison of algorithms much easier. See if you come up with the same following conclusions based on the graph:</p> <ul> <li>On average AND in the worst-case, Merge Sort will beat the others as \\(n\\) grows to be very large</li> <li>In the best-case, Insertion and Bubble are the best, showing they work best on almost sorted lists. Contrary to this Selection Sort remains quadratic, even with mostly sorted sequences.</li> <li>Even though Merge is the fastest computationally, it requires a linear growth of memory space, something that all the other sorts only need 1 of</li> </ul> <p>For quick assessments of algorithms bring up their graphs and compare their time-complexities visually. For most problems you should:</p> <ol> <li>Look for the worst-case time complexities (Big O)</li> <li>Compare them by graphing</li> <li>Pick the one that grows the slowest as it moves to the right</li> </ol>"},{"location":"lessons/4_big_o/#finding-dominant-components","title":"Finding Dominant Components","text":"<p>The full breakdowns of finding \\(T(n)\\) and then stripping away the constants and lower order growth factors can be tedious and time consuming if it has not been done for you, or if you are the one creating the algorithm. When analyzing an algorithm's time complexity, you don't need to count every single operation. Instead, look for the dominant component, the part that grows the fastest as input size increases. Here are some quick patterns to recognize:</p> <ul> <li>Single loop through n items? -&gt;\\(O(n)\\)</li> <li>Nested loops through n items? -&gt; \\(O(n\u00b2)\\)</li> <li>Dividing problem in half repeatedly? -&gt; \\(O(log n)\\)</li> <li>Loop that does log n iterations, each doing n work? -&gt; \\(O(n log n)\\)</li> <li>No loops, just a few operations? -&gt; \\(O(1)\\)</li> </ul>"},{"location":"lessons/4_big_o/#example-1-linear-search","title":"Example 1: Linear Search","text":"<ul> <li>Algorithm: Linear Search<ul> <li>Inputs: An array \\(A\\) of \\(n\\) numbers \\([a_0, a_1, ..., a_{n-1}]\\), and a target value \\(target\\)</li> <li>Output: Index of \\(target\\) in \\(A\\), or \\(-1\\) if not found</li> <li>Procedure:<ol> <li>\\(\\text{for } i \\gets 0 \\text{ to } n-1 \\text{ do:}\\)<ol> <li>\\(\\text{if } A[i] = target \\text{ then:}\\)<ol> <li>\\(\\text{return } i\\)</li> </ol> </li> <li>\\(\\text{end if}\\)</li> </ol> </li> <li>\\(\\text{end for}\\)</li> <li>\\(\\text{return } -1\\)</li> </ol> </li> </ul> </li> </ul> <p>Dominant Component: The single loop that potentially visits all \\(n\\) elements once. Time Complexity: \\(O(n)\\)</p>"},{"location":"lessons/4_big_o/#example-2-check-for-duplicates-naive","title":"Example 2: Check for Duplicates (Naive)","text":"<ul> <li>Algorithm: Has Duplicates<ul> <li>Inputs: An array \\(A\\) of \\(n\\) numbers \\([a_0, a_1, ..., a_{n-1}]\\)</li> <li>Output: \\(true\\) if any duplicates exist, \\(false\\) otherwise</li> <li>Procedure:<ol> <li>\\(\\text{for } i \\gets 0 \\text{ to } n-1 \\text{ do:}\\)<ol> <li>\\(\\text{for } j \\gets i+1 \\text{ to } n-1 \\text{ do:}\\)<ol> <li>\\(\\text{if } A[i] = A[j] \\text{ then:}\\)<ol> <li>\\(\\text{return } true\\)</li> </ol> </li> <li>\\(\\text{end if}\\)</li> </ol> </li> <li>\\(\\text{end for}\\)</li> </ol> </li> <li>\\(\\text{end for}\\)</li> <li>\\(\\text{return } false\\)</li> </ol> </li> </ul> </li> </ul> <p>Dominant Component: The nested loops where the outer loop runs \\(n\\) times and the inner loop runs up to \\(n\\) times for each iteration. Time Complexity: \\(O(n\u00b2)\\)</p>"}]}